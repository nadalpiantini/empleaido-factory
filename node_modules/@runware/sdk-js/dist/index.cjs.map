{"version":3,"sources":["../Runware/reconnect.ts","../Runware/index.ts","../Runware/types.ts","../Runware/utils.ts","../Runware/async-retry.ts","../Runware/Runware-base.ts","../Runware/Runware-client.ts","../Runware/Runware-server.ts","../Runware/Runware.ts"],"sourcesContent":["// @ts-nocheck\n/*\nReady state constants\nhttps://developer.mozilla.org/en-US/docs/Web/API/WebSocket#Ready_state_constants\n\nCONNECTING 0 The connection is not yet open.\nOPEN       1 The connection is open and ready to communicate.\nCLOSING    2 The connection is in the process of closing.\nCLOSED     3 The connection is closed or couldn't be opened.\n*/\ntype Options = {\n  constructor?: new (url: string, protocols?: string | string[]) => WebSocket;\n  maxReconnectionDelay?: number;\n  minReconnectionDelay?: number;\n  reconnectionDelayGrowFactor?: number;\n  connectionTimeout?: number;\n  maxRetries?: number;\n  debug?: boolean;\n};\n\nconst isWebSocket = (constructor) => constructor && constructor.CLOSING === 2;\n\nconst isGlobalWebSocket = () =>\n  typeof WebSocket !== \"undefined\" && isWebSocket(WebSocket);\n\nconst getDefaultOptions = () =>\n  <Options>{\n    constructor: isGlobalWebSocket() ? WebSocket : null,\n    maxReconnectionDelay: 10000,\n    minReconnectionDelay: 1500,\n    reconnectionDelayGrowFactor: 1.3,\n    connectionTimeout: 4000,\n    maxRetries: Infinity,\n    debug: false,\n  };\n\nconst bypassProperty = (src, dst, name: string) => {\n  Object.defineProperty(dst, name, {\n    get: () => src[name],\n    set: (value) => {\n      src[name] = value;\n    },\n    enumerable: true,\n    configurable: true,\n  });\n};\n\nconst initReconnectionDelay = (config: Options) =>\n  config.minReconnectionDelay + Math.random() * config.minReconnectionDelay;\n\nconst updateReconnectionDelay = (config: Options, previousDelay: number) => {\n  const newDelay = previousDelay * config.reconnectionDelayGrowFactor;\n  return newDelay > config.maxReconnectionDelay\n    ? config.maxReconnectionDelay\n    : newDelay;\n};\n\nconst LEVEL_0_EVENTS = [\"onopen\", \"onclose\", \"onmessage\", \"onerror\"];\n\nconst reassignEventListeners = (ws: WebSocket, oldWs, listeners) => {\n  Object.keys(listeners).forEach((type) => {\n    listeners[type].forEach(([listener, options]) => {\n      ws.addEventListener(type, listener, options);\n    });\n  });\n  if (oldWs) {\n    LEVEL_0_EVENTS.forEach((name) => {\n      ws[name] = oldWs[name];\n    });\n  }\n};\n\nconst ReconnectingWebsocket = function (\n  url: string,\n  protocols?: string | string[],\n  options = <Options>{}\n) {\n  let ws: WebSocket;\n  let connectingTimeout;\n  let reconnectDelay = 0;\n  let retriesCount = 0;\n  let shouldRetry = true;\n  const listeners: any = {};\n\n  // require new to construct\n  if (!(this instanceof ReconnectingWebsocket)) {\n    throw new TypeError(\n      \"Failed to construct 'ReconnectingWebSocket': Please use the 'new' operator\"\n    );\n  }\n\n  // Set config. Not using `Object.assign` because of IE11\n  const config = getDefaultOptions();\n  Object.keys(config)\n    .filter((key) => options.hasOwnProperty(key))\n    .forEach((key) => (config[key] = options[key]));\n\n  if (!isWebSocket(config.constructor)) {\n    throw new TypeError(\n      \"Invalid WebSocket constructor. Set `options.constructor`\"\n    );\n  }\n\n  const log = config.debug\n    ? (...params) => console.log(\"RWS:\", ...params)\n    : () => {};\n\n  /**\n   * Not using dispatchEvent, otherwise we must use a DOM Event object\n   * Deferred because we want to handle the close event before this\n   */\n  const emitError = (code: string, msg: string) =>\n    setTimeout(() => {\n      const err = <any>new Error(msg);\n      err.code = code;\n      if (Array.isArray(listeners.error)) {\n        listeners.error.forEach(([fn]) => fn(err));\n      }\n      if (ws.onerror) {\n        ws.onerror(err);\n      }\n    }, 0);\n\n  const handleClose = () => {\n    log(\"close\");\n    retriesCount++;\n    log(\"retries count:\", retriesCount);\n    if (retriesCount > config.maxRetries) {\n      emitError(\"EHOSTDOWN\", \"Too many failed connection attempts\");\n      return;\n    }\n    if (!reconnectDelay) {\n      reconnectDelay = initReconnectionDelay(config);\n    } else {\n      reconnectDelay = updateReconnectionDelay(config, reconnectDelay);\n    }\n    log(\"reconnectDelay:\", reconnectDelay);\n\n    if (shouldRetry) {\n      setTimeout(connect, reconnectDelay);\n    }\n  };\n\n  const connect = () => {\n    log(\"connect\");\n    const oldWs = ws;\n    ws = new (<any>config.constructor)(url, protocols);\n\n    connectingTimeout = setTimeout(() => {\n      log(\"timeout\");\n      ws.close();\n      emitError(\"ETIMEDOUT\", \"Connection timeout\");\n    }, config.connectionTimeout);\n\n    log(\"bypass properties\");\n    for (let key in ws) {\n      // @todo move to constant\n      if (\n        [\"addEventListener\", \"removeEventListener\", \"close\", \"send\"].indexOf(\n          key\n        ) < 0\n      ) {\n        bypassProperty(ws, this, key);\n      }\n    }\n\n    ws.addEventListener(\"open\", () => {\n      clearTimeout(connectingTimeout);\n      log(\"open\");\n      reconnectDelay = initReconnectionDelay(config);\n      log(\"reconnectDelay:\", reconnectDelay);\n      retriesCount = 0;\n    });\n\n    ws.addEventListener(\"close\", handleClose);\n\n    reassignEventListeners(ws, oldWs, listeners);\n  };\n\n  log(\"init\");\n  connect();\n\n  this.close = (\n    code = 1000,\n    reason = \"\",\n    { keepClosed = false, fastClose = true, delay = 0 } = {}\n  ) => {\n    if (delay) {\n      reconnectDelay = delay;\n    }\n    shouldRetry = !keepClosed;\n\n    ws.close(code, reason);\n\n    if (fastClose) {\n      const fakeCloseEvent = <CloseEvent>{\n        code,\n        reason,\n        wasClean: true,\n      };\n\n      // execute close listeners soon with a fake closeEvent\n      // and remove all close listeners from the WS instance\n      // so they don't get fired on the real close.\n\n      handleClose();\n\n      if (Array.isArray(listeners.close)) {\n        listeners.close.forEach(([listener, options]) => {\n          listener(fakeCloseEvent);\n          ws.removeEventListener(\"close\", listener, options);\n        });\n      }\n\n      if (ws.onclose) {\n        ws.onclose(fakeCloseEvent);\n        ws.onclose = null;\n      }\n    }\n  };\n\n  this.send = (data) => {\n    ws.send(data);\n  };\n\n  this.addEventListener = (\n    type: string,\n    listener: EventListener,\n    options: any\n  ) => {\n    if (Array.isArray(listeners[type])) {\n      if (!listeners[type].some(([l]) => l === listener)) {\n        listeners[type].push([listener, options]);\n      }\n    } else {\n      listeners[type] = [[listener, options]];\n    }\n    ws.addEventListener(type, listener, options);\n  };\n\n  this.removeEventListener = (\n    type: string,\n    listener: EventListener,\n    options: any\n  ) => {\n    if (Array.isArray(listeners[type])) {\n      listeners[type] = listeners[type].filter(([l]) => l !== listener);\n    }\n    ws.removeEventListener(type, listener, options);\n  };\n};\n\nexport = ReconnectingWebsocket;\n","export * from \"./Runware-client\";\nexport * from \"./types\";\n\nexport * from \"./Runware-server\";\nexport * from \"./Runware\";\n","export enum Environment {\n  PRODUCTION = \"PRODUCTION\",\n  DEVELOPMENT = \"DEVELOPMENT\",\n  TEST = \"TEST\",\n}\nexport enum SdkType {\n  CLIENT = \"CLIENT\",\n  SERVER = \"SERVER\",\n}\n\nexport enum ETaskType {\n  IMAGE_INFERENCE = \"imageInference\",\n  IMAGE_UPLOAD = \"imageUpload\",\n  UPSCALE = \"upscale\",\n  REMOVE_BACKGROUND = \"removeBackground\",\n  VIDEO_INFERENCE = \"videoInference\",\n  CAPTION = \"caption\",\n  AUDIO_INFERENCE = \"audioInference\",\n  GET_RESPONSE = \"getResponse\",\n  PHOTO_MAKER = \"photoMaker\",\n  IMAGE_CONTROL_NET_PRE_PROCESS = \"imageControlNetPreProcess\",\n  IMAGE_MASKING = \"imageMasking\",\n  PROMPT_ENHANCE = \"promptEnhance\",\n  AUTHENTICATION = \"authentication\",\n  MODEL_UPLOAD = \"modelUpload\",\n  MODEL_SEARCH = \"modelSearch\",\n  MEDIA_STORAGE = \"mediaStorage\",\n  VECTORIZE = \"vectorize\",\n}\n\nexport type RunwareBaseType = {\n  apiKey: string;\n  url?: string;\n  shouldReconnect?: boolean;\n  globalMaxRetries?: number;\n  timeoutDuration?: number;\n};\n\nexport type IOutputType = \"base64Data\" | \"dataURI\" | \"URL\";\nexport type IOutputFormat = \"JPG\" | \"PNG\" | \"WEBP\";\nexport type IVideoOutputFormat = \"MP4\" | \"WEBM\" | \"MOV\";\nexport type IAudioOutputFormat = \"MP3\"\n\nexport interface IAdditionalResponsePayload {\n  includePayload?: boolean;\n  includeGenerationTime?: boolean;\n}\n\nexport interface IImage {\n  taskType: ETaskType;\n  imageUUID?: string;\n  inputImageUUID?: string;\n  taskUUID: string;\n  status: string;\n  imageURL?: string;\n  imageBase64Data?: string;\n  imageDataURI?: string;\n  NSFWContent?: boolean;\n  cost?: number;\n  seed: number;\n  mediaUUID?: string;\n  mediaURL?: string;\n}\n\nexport interface ITextToImage extends IImage {\n  positivePrompt?: string;\n  negativePrompt?: string;\n}\n\nexport interface IVideoToImage {\n  taskUUID: string;\n  taskType: string;\n  status: string;\n  videoUUID?: string;\n  cost?: number;\n  seed?: number;\n  videoURL?: string;\n}\n\nexport interface IControlNetImage {\n  taskUUID: string;\n  inputImageUUID: string;\n  guideImageUUID: string;\n  guideImageURL?: string;\n  guideImageBase64Data?: string;\n  guideImageDataURI?: string;\n  cost?: number;\n}\n\ninterface ILora {\n  model: string | number;\n  weight: number;\n}\n\nexport enum EControlMode {\n  BALANCED = \"balanced\",\n  PROMPT = \"prompt\",\n  CONTROL_NET = \"controlnet\",\n}\n\nexport type IControlNetGeneral = {\n  model: string;\n  guideImage: string | File;\n  weight?: number;\n  startStep?: number;\n  startStepPercentage?: number;\n  endStep?: number;\n  endStepPercentage?: number;\n  controlMode: EControlMode;\n};\nexport type IControlNetPreprocess = {\n  inputImage: string | File;\n  preProcessorType: EPreProcessorGroup;\n  height?: number;\n  width?: number;\n  outputType?: IOutputType;\n  outputFormat?: IOutputFormat;\n  highThresholdCanny?: number;\n  lowThresholdCanny?: number;\n  includeHandsAndFaceOpenPose?: boolean;\n  includeCost?: boolean;\n  outputQuality?: number;\n\n  customTaskUUID?: string;\n  taskUUID?: string;\n  retry?: number;\n} & IAdditionalResponsePayload;\n\n// export type IControlNetA = RequireOnlyOne<\n//   IControlNetGeneral,\n//   \"guideImage\" | \"guideImageUnprocessed\"\n// >;\n\n// export type IControlNetCanny = IControlNetA & {\n//   preprocessor: \"canny\";\n//   lowThresholdCanny: Number;\n//   highThresholdCanny: Number;\n//   outputType?: IOutputType;\n// };\n\n// export type IControlNetHandsAndFace = IControlNetA & {\n//   preprocessor: keyof typeof EOpenPosePreProcessor;\n//   includeHandsAndFaceOpenPose: boolean;\n//   outputType?: IOutputType;\n// };\n\nexport type IControlNet = IControlNetGeneral;\n\nexport type IControlNetWithUUID = Omit<IControlNet, \"guideImage\"> & {\n  guideImage?: string;\n};\n\nexport interface IError {\n  error: boolean;\n  errorMessage: string;\n  taskUUID: string;\n}\n\nexport type TPromptWeighting = \"compel\" | \"sdEmbeds\";\n\nexport interface IRequestImage extends IAdditionalResponsePayload {\n  outputType?: IOutputType;\n  outputFormat?: IOutputFormat;\n  uploadEndpoint?: string;\n  checkNSFW?: boolean;\n  positivePrompt: string;\n  negativePrompt?: string;\n  seedImage?: File | string;\n  maskImage?: File | string;\n  strength?: number;\n  height?: number;\n  width?: number;\n  model: number | string;\n  steps?: number;\n  scheduler?: string;\n  seed?: number;\n  maskMargin?: number;\n  CFGScale?: number;\n  clipSkip?: number;\n  /**\n   * @deprecated The usePromptWeighting should not be used, use promptWeighting instead\n   */\n  usePromptWeighting?: boolean;\n  promptWeighting?: TPromptWeighting;\n  numberResults?: number; // default to 1\n  includeCost?: boolean;\n  outputQuality?: number;\n\n  controlNet?: IControlNet[];\n  lora?: ILora[];\n  embeddings?: IEmbedding[];\n  ipAdapters?: IipAdapter[];\n  providerSettings?: IProviderSettings;\n  outpaint?: IOutpaint;\n  refiner?: IRefiner;\n  acceleratorOptions?: TAcceleratorOptions;\n  advancedFeatures?: {\n    layerDiffuse: boolean;\n  };\n  referenceImages?: string[];\n\n  // imageSize?: number;\n  customTaskUUID?: string;\n  onPartialImages?: (images: IImage[], error?: IError) => void;\n  retry?: number;\n  // gScale?: number;\n\n  [key: string]: any;\n}\n\nexport type TAcceleratorOptions =\n  | { teaCache: boolean; teaCacheDistance: number }\n  | {\n      deepCache: boolean;\n      deepCacheInterval: number;\n      deepCacheBranchId: number;\n    };\n\nexport interface IOutpaint {\n  top?: number;\n  bottom?: number;\n  right?: number;\n  left?: number;\n  blur?: number;\n}\nexport interface IEmbedding {\n  model: string;\n  weight: number;\n}\nexport interface IipAdapter {\n  model: string;\n  weight: number;\n  guideImage: string;\n}\n\nexport interface IBflProviderSettings {\n  promptUpsampling?: boolean;\n  safetyTolerance?: number;\n  raw?: boolean;\n}\n\nexport type ProviderSettings = {\n  bfl: IBflProviderSettings;\n};\n\nexport type IProviderSettings = RequireOnlyOne<\n  ProviderSettings,\n  keyof ProviderSettings\n>;\n\nexport interface IRefiner {\n  model: string;\n  startStep?: number;\n  startStepPercentage?: number;\n}\nexport interface IRequestImageToText extends IAdditionalResponsePayload {\n  model?: string;\n  inputImage?: File | string;\n  inputs?: {\n    video?: InputsValue;\n  } & {\n    [key: string]: unknown;\n  };\n  includeCost?: boolean;\n  customTaskUUID?: string;\n  taskUUID?: string;\n  retry?: number;\n\n  deliveryMethod?: string;\n  skipResponse?: boolean;\n}\nexport interface IImageToText {\n  taskType: ETaskType;\n  taskUUID: string;\n  status: string;\n  text: string;\n  cost?: number;\n}\n\nexport interface IRemoveImageBackground extends IRequestImageToText {\n  outputType?: IOutputType;\n  outputFormat?: IOutputFormat| \"MP4\" | \"WEBM\" | \"MOV\";\n  model: string;\n  inputs?: {\n    video?: InputsValue;\n    image?: InputsValue;\n  }\n  settings?: {\n    rgba?: number[];\n    postProcessMask?: boolean;\n    returnOnlyMask?: boolean;\n    alphaMatting?: boolean;\n    alphaMattingForegroundThreshold?: number;\n    alphaMattingBackgroundThreshold?: number;\n    alphaMattingErodeSize?: number;\n  };\n  includeCost?: boolean;\n  outputQuality?: number;\n  retry?: number;\n\n  skipResponse?: boolean;\n  deliveryMethod?: string;\n}\n\n\ntype InputsValue = string | Record<string, unknown>;\n\nexport interface IRequestVideo extends IRequestImageToText {\n  outputType?: IOutputType;\n  outputFormat?: IVideoOutputFormat;\n  outputQuality?: number;\n  uploadEndpoint?: string;\n  checkNSFW?: boolean;\n  includeCost?: boolean;\n  positivePrompt?: string;\n  negativePrompt?: string;\n  model: string;\n  steps?: number;\n  CFGScale?: number;\n  seed?: number;\n  duration?: number;\n  fps?: number;\n  width?: number;\n  height?: number;\n  numberResults?: number;\n  inputAudios?: string[];\n  referenceVideos?: string[];\n  inputs?: {\n    image?: InputsValue;\n    images?: InputsValue[];\n    audio?: InputsValue;\n    audios?: InputsValue[];\n    mask?: InputsValue[];\n    reference?: InputsValue;\n    references?: InputsValue[];\n  } & {\n    [key: string]: unknown;\n  };\n  speech?: {\n    voice: string;\n    text: string;\n  };\n  skipResponse?: boolean;\n  customTaskUUID?: string;\n  retry?: number;\n\n  [key: string]: any;\n}\n\nexport interface IAudio {\n  taskUUID: string;\n  taskType: string;\n  status: string;\n  audioUUID?: string;\n  audioURL?: string;\n  audioBase64Data?: string;\n  audioDataURI?: string;\n  cost?: number;\n}\n\nexport interface IRequestAudio {\n  model: string;\n  numberResults?: number;\n  outputType?: IOutputType;\n  outputFormat?: IAudioOutputFormat;\n  uploadEndpoint?: string;\n  includeCost?: boolean;\n  positivePrompt?: string;\n  duration?: number;\n  audioSettings?: {\n    sampleRate?: number;\n    bitrate?: number;\n  } & {\n    [key: string]: unknown;\n  };\n  inputs?: {\n    video?: InputsValue;\n  } & {\n    [key: string]: unknown;\n  };\n  deliveryMethod?: string;\n  \n  taskUUID?: string;\n  customTaskUUID?: string;\n\n  skipResponse?: boolean;\n  retry?: number;\n\n  [key: string]: unknown;\n}\n\nexport interface IAsyncResults {\n  taskUUID: string;\n  onPartialImages?: (images: IImage[], error?: IError) => void;\n}\n\nexport interface IRemoveImage {\n  taskType: ETaskType;\n  taskUUID: string;\n  status: string;\n  imageUUID?: string;\n  mediaUUID?: string;\n  mediaURL?: string;\n  videoUUID?: string;\n  inputImageUUID: string;\n  imageURL?: string;\n  imageBase64Data?: string;\n  imageDataURI?: string;\n  cost?: number;\n}\n\nexport interface IPromptEnhancer extends IAdditionalResponsePayload {\n  promptMaxLength?: number;\n  promptVersions?: number;\n  prompt: string;\n  includeCost?: boolean;\n  customTaskUUID?: string;\n  taskUUID?: string;\n  retry?: number;\n}\n\nexport interface IEnhancedPrompt extends IImageToText {}\n\nexport interface IUpscaleGan extends IAdditionalResponsePayload {\n  inputImage?: File | string;\n  upscaleFactor: number;\n  outputType?: IOutputType;\n  outputFormat?: IOutputFormat | \"MP4\" | \"WEBM\" | \"MOV\";\n  includeCost?: boolean;\n  outputQuality?: number;\n\n  inputs?: {\n    video?: InputsValue;\n    image?: InputsValue;\n  } & {\n    [key: string]: unknown;\n  }\n  model?: string;\n\n  customTaskUUID?: string;\n  taskUUID?: string;\n  retry?: number;\n\n  skipResponse?: boolean;\n  deliveryMethod?: string;\n}\n\nexport type ReconnectingWebsocketProps = {\n  addEventListener: (\n    type: string,\n    listener: EventListener,\n    options: any\n  ) => void;\n  send: (data: any) => void;\n} & WebSocket;\n\nexport type UploadImageType = {\n  imageURL: string;\n  imageUUID: string;\n  taskUUID: string;\n  taskType: ETaskType;\n};\n\nexport type GetWithPromiseCallBackType = ({\n  resolve,\n  reject,\n  intervalId,\n}: {\n  resolve: <T>(value: T) => void;\n  reject: <T>(value: T) => void;\n  intervalId: any;\n}) => boolean | undefined;\n\nexport type GetWithPromiseAsyncCallBackType = ({\n  resolve,\n  reject,\n  intervalId,\n}: {\n  resolve: <T>(value: T) => void;\n  reject: <T>(value: T) => void;\n  intervalId: any;\n}) => any;\n\nexport enum EPreProcessorGroup {\n  \"canny\" = \"canny\",\n  \"depth\" = \"depth\",\n  \"mlsd\" = \"mlsd\",\n  \"normalbae\" = \"normalbae\",\n  \"openpose\" = \"openpose\",\n  \"tile\" = \"tile\",\n  \"seg\" = \"seg\",\n  \"lineart\" = \"lineart\",\n  \"lineart_anime\" = \"lineart_anime\",\n  \"shuffle\" = \"shuffle\",\n  \"scribble\" = \"scribble\",\n  \"softedge\" = \"softedge\",\n}\n\nexport enum EPreProcessor {\n  \"canny\" = \"canny\",\n  \"depth_leres\" = \"depth_leres\",\n  \"depth_midas\" = \"depth_midas\",\n  \"depth_zoe\" = \"depth_zoe\",\n  \"inpaint_global_harmonious\" = \"inpaint_global_harmonious\",\n  \"lineart_anime\" = \"lineart_anime\",\n  \"lineart_coarse\" = \"lineart_coarse\",\n  \"lineart_realistic\" = \"lineart_realistic\",\n  \"lineart_standard\" = \"lineart_standard\",\n  \"mlsd\" = \"mlsd\",\n  \"normal_bae\" = \"normal_bae\",\n\n  \"scribble_hed\" = \"scribble_hed\",\n  \"scribble_pidinet\" = \"scribble_pidinet\",\n  \"seg_ofade20k\" = \"seg_ofade20k\",\n  \"seg_ofcoco\" = \"seg_ofcoco\",\n  \"seg_ufade20k\" = \"seg_ufade20k\",\n  \"shuffle\" = \"shuffle\",\n  \"softedge_hed\" = \"softedge_hed\",\n  \"softedge_hedsafe\" = \"softedge_hedsafe\",\n  \"softedge_pidinet\" = \"softedge_pidinet\",\n  \"softedge_pidisafe\" = \"softedge_pidisafe\",\n  \"tile_gaussian\" = \"tile_gaussian\",\n\n  \"openpose\" = \"openpose\",\n  \"openpose_face\" = \"openpose_face\",\n  \"openpose_faceonly\" = \"openpose_faceonly\",\n  \"openpose_full\" = \"openpose_full\",\n  \"openpose_hand\" = \"openpose_hand\",\n}\n\nexport enum EOpenPosePreProcessor {\n  \"openpose\" = \"openpose\",\n  \"openpose_face\" = \"openpose_face\",\n  \"openpose_faceonly\" = \"openpose_faceonly\",\n  \"openpose_full\" = \"openpose_full\",\n  \"openpose_hand\" = \"openpose_hand\",\n}\n\nexport type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<\n  T,\n  Exclude<keyof T, Keys>\n> &\n  {\n    [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>;\n  }[Keys];\n\nexport type RequireOnlyOne<T, Keys extends keyof T = keyof T> = Pick<\n  T,\n  Exclude<keyof T, Keys>\n> &\n  {\n    [K in Keys]-?: Required<Pick<T, K>> &\n      Partial<Record<Exclude<Keys, K>, undefined>>;\n  }[Keys];\n\nexport type ListenerType = {\n  key: string;\n  listener: (msg: any) => void;\n  groupKey?: string;\n};\n\nexport interface IAddModelResponse {\n  status: string;\n  message: string;\n  taskUUID: string;\n  air: string;\n  taskType: string;\n}\n\nexport interface IErrorResponse {\n  code: string;\n  message: string;\n  parameter: string;\n  type: string;\n  documentation: string;\n  taskUUID: string;\n  min?: number;\n  max?: number;\n  default?: string | number;\n}\n\nexport type TAddModelBaseType = {\n  air: string;\n  name: string;\n  downloadURL: string;\n  uniqueIdentifier: string;\n\n  version: string;\n  format: EModelFormat;\n  architecture: EModelArchitecture;\n  heroImageURL?: string;\n  tags?: string[];\n  shortDescription?: string;\n  comment?: string;\n  private: boolean;\n\n  // Custom parameters\n  customTaskUUID?: string;\n  taskUUID?: string;\n  retry?: number;\n  onUploadStream?: (\n    response?: IAddModelResponse,\n    error?: IErrorResponse\n  ) => void;\n};\n\nexport type TAddModelControlNet = {\n  category: \"controlnet\";\n  conditioning: EModelConditioning;\n} & TAddModelBaseType;\n\nexport type TAddModelCheckPoint = {\n  category: \"checkpoint\";\n  defaultCFGScale?: number;\n  defaultStrength: number;\n  defaultSteps?: number;\n  defaultScheduler?: string;\n  type: EModelType;\n} & TAddModelBaseType;\n\nexport type TAddModelLora = {\n  category: \"lora\";\n  defaultWeight: number;\n  positiveTriggerWords?: string;\n} & TAddModelBaseType;\n\nexport type TAddModel =\n  | TAddModelCheckPoint\n  | TAddModelControlNet\n  | TAddModelLora;\n\nexport type TPhotoMaker = {\n  style: EPhotoMakerEnum;\n  inputImages: string[];\n  outputType?: string;\n  outputFormat?: string;\n  uploadEndpoint?: string;\n  checkNSFW?: boolean;\n  positivePrompt: string;\n  negativePrompt?: string;\n  strength?: number;\n  height: number;\n  width: number;\n  model?: string; // this should be hidden for now cause we have a single model\n  steps?: number;\n  scheduler?: string;\n  seed?: number;\n  CFGScale?: number;\n  clipSkip?: number;\n  numberResults: number;\n  includeCost?: boolean;\n  outputQuality?: number;\n\n  // other options\n  customTaskUUID?: string;\n  taskUUID?: string;\n  retry?: number;\n  onPartialImages?: (images: IImage[], error?: IError) => void;\n} & IAdditionalResponsePayload;\n\nexport type TPhotoMakerResponse = {\n  taskType: string;\n  taskUUID: string;\n  status: string;\n  imageUUID: string;\n  NSFWContent: boolean;\n  cost: number;\n  seed: number;\n  imageURL: string;\n  positivePrompt: string;\n  negativePrompt?: string;\n};\n\nexport enum EModelFormat {\n  safetensors = \"safetensors\",\n  pickletensor = \"pickletensor\",\n}\n\nexport enum EModelArchitecture {\n  flux1d = \"flux1d\",\n  flux1s = \"flux1s\",\n  pony = \"pony\",\n  sdhyper = \"sdhyper\",\n  sd1x = \"sd1x\",\n  sd1xlcm = \"sd1xlcm\",\n  sd3 = \"sd3\",\n  sdxl = \"sdxl\",\n  sdxllcm = \"sdxllcm\",\n  sdxldistilled = \"sdxldistilled\",\n  sdxlhyper = \"sdxlhyper\",\n  sdxllightning = \"sdxllightning\",\n  sdxlturbo = \"sdxlturbo\",\n}\n\nexport enum EModelType {\n  base = \"base\",\n  inpainting = \"inpainting\",\n  pix2pix = \"pix2pix\",\n}\n\nexport enum EModelConditioning {\n  canny = \"canny\",\n  depth = \"depth\",\n  qrcode = \"qrcode\",\n  hed = \"hed\",\n  scrible = \"scrible\",\n  openpose = \"openpose\",\n  seg = \"segmentation\",\n  openmlsd = \"openmlsd\",\n  softedge = \"softedge\",\n  normal = \"normal bae\",\n  shuffle = \"shuffle\",\n  pix2pix = \"pix2pix\",\n  inpaint = \"inpaint\",\n  lineart = \"line art\",\n  sketch = \"sketch\",\n  inpaintdepth = \"inpaint depth\",\n  tile = \"tile\",\n  outfit = \"outfit\",\n  blur = \"blur\",\n  gray = \"gray\",\n  lowquality = \"low quality\",\n}\n\nexport enum EPhotoMakerEnum {\n  NoStyle = \"No style\",\n  Cinematic = \"Cinematic\",\n  DisneyCharacter = \"Disney Character\",\n  DigitalArt = \"Digital Art\",\n  Photographic = \"Photographic\",\n  FantasyArt = \"Fantasy art\",\n  Neonpunk = \"Neonpunk\",\n  Enhance = \"Enhance\",\n  ComicBook = \"Comic book\",\n  Lowpoly = \"Lowpoly\",\n  LineArt = \"Line art\",\n}\n\nexport type TModelSearch = {\n  search?: string;\n  tags?: string[];\n  category?: \"checkpoint\" | \"lora\" | \"controlnet\";\n  type?: string;\n  architecture?: EModelArchitecture;\n  conditioning?: string;\n  visibility?: \"public\" | \"private\" | \"all\";\n  limit?: number;\n  offset?: number;\n\n  // other options\n  customTaskUUID?: string;\n  retry?: number;\n} & { [key: string]: any };\n\nexport type TModel = {\n  air: string;\n  name: string;\n  version: string;\n  category: string;\n  architecture: string;\n  tags: string[];\n  heroImage: string;\n  private: boolean;\n  comment: string;\n\n  // Optionals\n  type?: string;\n  defaultWidth?: number;\n  defaultHeight?: number;\n  defaultSteps?: number;\n  defaultScheduler?: string;\n  defaultCFG?: number;\n  defaultStrength: number;\n  conditioning?: string;\n  positiveTriggerWords?: string;\n} & { [key: string]: any };\n\nexport type TModelSearchResponse = {\n  results: TModel[];\n  taskUUID: string;\n  taskType: string;\n  totalResults: number;\n};\n\nexport type TImageMasking = {\n  model: string;\n  inputImage: string;\n  confidence?: number;\n  maskPadding?: number;\n  maskBlur?: number;\n  outputFormat?: string;\n  outputType?: string;\n  includeCost?: boolean;\n  uploadEndpoint?: string;\n  maxDetections?: number;\n  outputQuality?: number;\n\n  customTaskUUID?: string;\n  retry?: number;\n};\nexport type TVectorize = {\n  model: string;\n  outputFormat?: string;\n  outputType?: string;\n  includeCost?: boolean;\n  inputs: {\n    image: string;\n  };\n\n  customTaskUUID?: string;\n  retry?: number;\n};\n\nexport type TVectorizeResponse = {\n  taskType: string;\n  taskUUID: string;\n  cost: number;\n  imageURL: string;\n};\n\nexport type TImageUpload = {\n  image: string;\n\n  customTaskUUID?: string;\n  retry?: number;\n};\n\nexport type TMediaStorage = {\n  media: string;\n  operation?: string;\n  customTaskUUID?: string;\n  retry?: number;\n};\nexport type TMediaStorageResponse = {\n  taskType: string;\n  taskUUID: string;\n  mediaUUID: string;\n};\n\nexport type TImageUploadResponse = {\n  image: string;\n  taskUUID: string;\n  imageUUID: number;\n  imageURL: string;\n};\n\nexport type TImageMaskingResponse = {\n  taskType: string;\n  taskUUID: string;\n  maskImageUUID: string;\n\n  detections: [\n    {\n      x_min: number;\n      y_min: number;\n      x_max: number;\n      y_max: number;\n    }\n  ];\n  maskImageURL: string;\n  cost: number;\n};\n\nexport type TServerError = {\n  error: {\n    code: string;\n    message: string;\n    parameter: string;\n    type: string;\n    taskType: string;\n  };\n};\n\nexport type MediaUUID = {\n  mediaUUID?: string;\n  audioUUID?: string;\n  imageUUID?: string;\n  videoUUID?: string;\n}","import {\n  EPreProcessor,\n  EPreProcessorGroup,\n  Environment,\n  GetWithPromiseAsyncCallBackType,\n  GetWithPromiseCallBackType,\n  IRequestImage,\n} from \"./types\";\nimport { v4 as uuidv4, validate as validateUUID } from \"uuid\";\n\nexport const TIMEOUT_DURATION = 60000; // 120S;\nexport const MINIMUM_TIMEOUT_DURATION = 1000; // 120S;\nconst POLLING_INTERVAL = 100; // 1s;\n\nexport const BASE_RUNWARE_URLS = {\n  [Environment.PRODUCTION]: \"wss://ws-api.runware.ai/v1\",\n  [Environment.TEST]: \"ws://localhost:8080\",\n};\n\nexport const removeFromAray = <T>(col: T[], targetElem: T) => {\n  if (col == null) {\n    return;\n  }\n  let i = col.indexOf(targetElem);\n  if (i === -1) {\n    return;\n  }\n  col.splice(i, 1);\n};\n\nexport const getIntervalWithPromise = (\n  callback: GetWithPromiseCallBackType,\n  {\n    debugKey = \"debugKey\",\n    timeoutDuration = TIMEOUT_DURATION,\n    shouldThrowError = true,\n    pollingInterval = POLLING_INTERVAL,\n  }: {\n    debugKey?: string;\n    timeoutDuration?: number;\n    shouldThrowError?: boolean;\n    pollingInterval?: number;\n  }\n) => {\n  timeoutDuration =\n    timeoutDuration < MINIMUM_TIMEOUT_DURATION\n      ? MINIMUM_TIMEOUT_DURATION\n      : timeoutDuration;\n\n  return new Promise((resolve, reject) => {\n    const timeoutId = setTimeout(() => {\n      if (intervalId) {\n        clearInterval(intervalId);\n        if (shouldThrowError) {\n          reject(`Response could not be received from server for ${debugKey}`);\n        }\n      }\n      clearTimeout(timeoutId);\n      // reject();\n    }, timeoutDuration);\n\n    let intervalId = setInterval(async () => {\n      const shouldClear = callback({ resolve, reject, intervalId });\n\n      if (shouldClear) {\n        clearInterval(intervalId);\n        clearTimeout(timeoutId);\n      }\n      // resolve(imagesWithSimilarTask); // Resolve the promise with the data\n    }, pollingInterval); // Check every 1 second (adjust the interval as needed)\n  });\n};\n\nexport const fileToBase64 = (file: File) =>\n  new Promise((resolve) => {\n    const reader = new FileReader();\n    reader.readAsDataURL(file);\n    reader.onload = function () {\n      resolve(reader.result);\n    };\n  });\n\n// export const getUUID = () => crypto.randomUUID();\nexport const getUUID = () => uuidv4();\n\nexport const isValidUUID = (uuid: string) => validateUUID(uuid);\n\nconst evaluateToBoolean = (...args: any) => [...args].every((e) => !!e);\n\nexport const compact = (value: any, data: any) => (!!value ? data : {});\n\nexport const getPreprocessorType = (\n  processor: EPreProcessor\n): EPreProcessorGroup => {\n  const processorGroup = Object.keys(\n    EPreProcessorGroup\n  ) as EPreProcessorGroup[];\n\n  switch (processor) {\n    case EPreProcessor.canny:\n      return EPreProcessorGroup.canny;\n    // break\n    case EPreProcessor.depth_leres:\n    case EPreProcessor.depth_midas:\n    case EPreProcessor.depth_zoe:\n      return EPreProcessorGroup.depth;\n    // break\n    case EPreProcessor.inpaint_global_harmonious:\n      return EPreProcessorGroup.depth;\n    // break\n    case EPreProcessor.lineart_anime:\n      return EPreProcessorGroup.lineart_anime;\n    // break\n    case EPreProcessor.lineart_coarse:\n    case EPreProcessor.lineart_realistic:\n    case EPreProcessor.lineart_standard:\n      return EPreProcessorGroup.lineart;\n    // break\n    case EPreProcessor.mlsd:\n      return EPreProcessorGroup.mlsd;\n    // break\n    case EPreProcessor.normal_bae:\n      return EPreProcessorGroup.normalbae;\n    // break\n    case EPreProcessor.openpose_face:\n    case EPreProcessor.openpose_faceonly:\n    case EPreProcessor.openpose_full:\n    case EPreProcessor.openpose_hand:\n    case EPreProcessor.openpose:\n      return EPreProcessorGroup.openpose;\n    // break\n    case EPreProcessor.scribble_hed:\n    case EPreProcessor.scribble_pidinet:\n      return EPreProcessorGroup.scribble;\n    // break\n    case EPreProcessor.seg_ofade20k:\n    case EPreProcessor.seg_ofcoco:\n    case EPreProcessor.seg_ufade20k:\n      return EPreProcessorGroup.seg;\n    // break\n    case EPreProcessor.shuffle:\n      return EPreProcessorGroup.shuffle;\n    // break\n    case EPreProcessor.softedge_hed:\n    case EPreProcessor.softedge_hedsafe:\n    case EPreProcessor.softedge_pidinet:\n    case EPreProcessor.softedge_pidisafe:\n      return EPreProcessorGroup.softedge;\n    // break\n    case EPreProcessor.tile_gaussian:\n      return EPreProcessorGroup.tile;\n    // break\n    default:\n      return EPreProcessorGroup.canny;\n  }\n};\n\nexport const accessDeepObject = ({\n  key,\n  data,\n  useZero = true,\n  shouldReturnString = false,\n}: {\n  key: string;\n  data: Record<string, any>;\n  useZero?: boolean;\n  shouldReturnString?: boolean;\n}) => {\n  const splittedKeys = key.split(/\\.|\\[/).map((key) => key.replace(/\\]$/, \"\"));\n\n  const value = splittedKeys.reduce((acc, curr) => {\n    const returnZero = useZero ? 0 : undefined;\n    const currentValue = acc?.[curr];\n\n    if (!currentValue) {\n      return returnZero;\n    }\n    if (Array.isArray(currentValue) && /^\\d+$/.test(curr)) {\n      const index = parseInt(curr, 10);\n      if (index >= 0 && index < currentValue.length) {\n        return (acc[curr] = currentValue[index]);\n      } else {\n        return acc[curr] ?? returnZero;\n      }\n    } else {\n      return acc[curr] ?? returnZero;\n    }\n  }, data || {});\n\n  // if (typeof value === \"object\" && shouldReturnString) {\n  //   return JSON.stringify(value);\n  // }\n  return value ?? {};\n};\n\nexport const delay = (time: number, milliseconds = 1000) => {\n  return new Promise((resolve) => setTimeout(resolve, time * milliseconds));\n};\n\nexport class MockFile {\n  create = function (name: string, size: number, mimeType: string) {\n    name = name || \"mock.txt\";\n    size = size || 1024;\n    mimeType = mimeType || \"plain/txt\";\n\n    var blob: any = new Blob([range(size)], { type: mimeType });\n    blob.lastModifiedDate = new Date();\n    blob.name = name;\n\n    return blob;\n  };\n}\n\nfunction range(count: number) {\n  var output = \"\";\n  for (var i = 0; i < count; i++) {\n    output += \"a\";\n  }\n  return output;\n}\n\nexport const RETRY_SDK_COUNTS = {\n  GLOBAL: 2,\n  REQUEST_IMAGES: 2,\n};\n\nexport const remove1Mutate = (col: any, targetElem: any) => {\n  if (col == null) {\n    return;\n  }\n\n  let i = col.indexOf(targetElem);\n  if (i === -1) {\n    return;\n  }\n  col.splice(i, 1);\n};\n\nexport const removeListener = (listeners: any[], listener: any) => {\n  return listeners.filter((lis) => lis.key !== listener.key);\n};\n\nexport const removeAllKeyListener = ({\n  listeners,\n  key,\n}: {\n  listeners: any[];\n  key: any;\n}) => {\n  return listeners.filter((lis) => lis?.key !== key);\n};\n\nexport enum LISTEN_TO_MEDIA_KEY {\n  REQUEST_IMAGES = \"REQUEST_IMAGES\",\n  REQUEST_AUDIO = \"REQUEST_AUDIO\"\n}\n\nexport const evaluateNonTrue = ({\n  key,\n  value,\n}: {\n  key: string;\n  value: any;\n}) => {\n  if (!!value || value === 0 || value === false) {\n    return { [key]: value };\n  } else {\n    return {};\n  }\n};\n\nexport const getRandomNumber = (min: number, max: number) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\nexport const getRandomSeed = () => {\n  return getRandomNumber(1, Number.MAX_SAFE_INTEGER);\n};\n\nexport const getIntervalAsyncWithPromise = (\n  callback: GetWithPromiseAsyncCallBackType,\n  {\n    debugKey = \"debugKey\",\n    timeoutDuration = TIMEOUT_DURATION,\n    shouldThrowError = true,\n    pollingInterval = POLLING_INTERVAL,\n  }: {\n    debugKey?: string;\n    timeoutDuration?: number;\n    shouldThrowError?: boolean;\n    pollingInterval?: number;\n  }\n) => {\n  timeoutDuration =\n    timeoutDuration < MINIMUM_TIMEOUT_DURATION\n      ? MINIMUM_TIMEOUT_DURATION\n      : timeoutDuration;\n\n  return new Promise((resolve, reject) => {\n    const timeoutId = setTimeout(() => {\n      if (intervalId) {\n        clearInterval(intervalId);\n        if (shouldThrowError) {\n          reject(`Response could not be received from server for ${debugKey}`);\n        }\n      }\n      clearTimeout(timeoutId);\n    }, timeoutDuration);\n\n    let intervalId = setInterval(async () => {\n      try {\n        const shouldClear = await callback({ resolve, reject, intervalId });\n        if (shouldClear) {\n          clearInterval(intervalId);\n          clearTimeout(timeoutId);\n        }\n      } catch (error) {\n        clearInterval(intervalId);\n        clearTimeout(timeoutId);\n        reject(error);\n      }\n    }, pollingInterval);\n  });\n};\n\nexport const isUrl = (value: any): value is string => {\n  return (\n    typeof value === \"string\" &&\n    (value.startsWith(\"http:\") ||\n      value.startsWith(\"https:\"))\n  );\n};","import { delay } from \"./utils\";\n\nexport const asyncRetry = async (\n  apiCall: Function,\n  options: {\n    maxRetries?: number;\n    delayInSeconds?: number;\n    callback?: Function;\n  } = {}\n) => {\n  const { delayInSeconds = 1, callback } = options;\n  let maxRetries = options.maxRetries ?? 1;\n  while (maxRetries) {\n    try {\n      const result = await apiCall();\n      return result; // Return the result if successful\n    } catch (error: any) {\n      callback?.();\n      if (error?.error) {\n        throw error;\n      }\n      maxRetries--;\n      if (maxRetries > 0) {\n        await delay(delayInSeconds); // Delay before the next retry\n        await asyncRetry(apiCall, { ...options, maxRetries });\n      } else {\n        throw error; // Throw the error if max retries are reached\n      }\n    }\n  }\n};\n","// @ts-ignore\nimport { asyncRetry } from \"./async-retry\";\nimport {\n  EControlMode,\n  IControlNet,\n  IControlNetWithUUID,\n  IEnhancedPrompt,\n  IError,\n  IImage,\n  IImageToText,\n  IPromptEnhancer,\n  IRemoveImageBackground,\n  IRequestImage,\n  IRequestImageToText,\n  IUpscaleGan,\n  ListenerType,\n  ReconnectingWebsocketProps,\n  RunwareBaseType,\n  SdkType,\n  UploadImageType,\n  ETaskType,\n  IControlNetPreprocess,\n  IControlNetImage,\n  IRemoveImage,\n  ITextToImage,\n  TAddModel,\n  IAddModelResponse,\n  IErrorResponse,\n  TPhotoMaker,\n  TPhotoMakerResponse,\n  TModelSearch,\n  TImageMaskingResponse,\n  TImageMasking,\n  TModelSearchResponse,\n  TServerError,\n  TImageUpload,\n  TImageUploadResponse,\n  IRequestVideo,\n  IAsyncResults,\n  IVideoToImage,\n  TMediaStorage,\n  TMediaStorageResponse,\n  TVectorize,\n  TVectorizeResponse,\n  IRequestAudio,\n  IAudio,\n  MediaUUID,\n} from \"./types\";\nimport {\n  BASE_RUNWARE_URLS,\n  LISTEN_TO_MEDIA_KEY,\n  TIMEOUT_DURATION,\n  accessDeepObject,\n  delay,\n  evaluateNonTrue,\n  fileToBase64,\n  getIntervalAsyncWithPromise,\n  getIntervalWithPromise,\n  getRandomSeed,\n  getUUID,\n  isValidUUID,\n  removeFromAray,\n  removeListener,\n  isUrl,\n} from \"./utils\";\n\n// let allImages: IImage[] = [];\n\nexport class RunwareBase {\n  _ws: ReconnectingWebsocketProps | any;\n  _listeners: ListenerType[] = [];\n  _apiKey: string;\n  _url?: string;\n  // _globalMessages: any[] = [];\n  _globalMessages: Record<string, any> = {};\n  _globalImages: IImage[] = [];\n  _globalError: IError | undefined;\n  _connectionSessionUUID: string | undefined;\n  _connectionError: TServerError | undefined;\n  _sdkType: SdkType;\n  _shouldReconnect: boolean;\n  _globalMaxRetries: number;\n  _timeoutDuration: number;\n  ensureConnectionUUID: string | null = null;\n\n  constructor({\n    apiKey,\n    url = BASE_RUNWARE_URLS.PRODUCTION,\n    shouldReconnect = true,\n    globalMaxRetries = 2,\n    timeoutDuration = TIMEOUT_DURATION,\n  }: RunwareBaseType) {\n    this._apiKey = apiKey;\n    this._url = url;\n    this._sdkType = SdkType.CLIENT;\n    this._shouldReconnect = shouldReconnect;\n    this._globalMaxRetries = globalMaxRetries;\n    this._timeoutDuration = timeoutDuration;\n  }\n\n  \n\n  private getUniqueUUID(item: MediaUUID): string | undefined {\n    return item.mediaUUID || item.audioUUID  || item.imageUUID  || item.videoUUID;\n  }\n\n  /**\n   * Shared polling logic for async results.\n   * @param taskUUID - The task UUID to poll for.\n   * @param numberResults - Number of results expected.\n   * @returns Promise resolving to array of results.\n   */\n  private async pollForAsyncResults<T extends { status: string; } & MediaUUID>({\n    taskUUID,\n    numberResults = 1,\n  }: {\n    taskUUID: string;\n    numberResults?: number;\n  }): Promise<T[]> {\n    const allResults = new Map<string, T>();\n    await getIntervalAsyncWithPromise(\n      async ({ resolve, reject }) => {\n        try {\n          const response = await this.getResponse<T>({ taskUUID });\n          \n\n          // Add results to the collection\n          for (const responseItem of response || []) {\n            if (responseItem.status === \"success\") {\n              const uuid = this.getUniqueUUID(responseItem);\n              if (uuid) {\n                allResults.set(uuid, responseItem);\n              }\n            }\n          }\n\n          // Check completion AFTER updating the collection\n          const isComplete = allResults.size === numberResults;\n\n          if (isComplete) {\n            resolve(Array.from(allResults.values()));\n            return true; // Signal to clear the interval\n          }\n\n          return false;\n        } catch (err) {\n          reject(err);\n          return true;\n        }\n      },\n      {\n        debugKey: \"async-response\",\n        pollingInterval: 2 * 1000,\n        timeoutDuration: 10 * 60 * 1000,\n      }\n    );\n    return Array.from(allResults.values());\n  }\n\n  static async initialize(props: RunwareBaseType) {\n    try {\n      const instance = new this(props);\n      await instance.ensureConnection();\n      return instance;\n    } catch (e) {\n      throw e;\n    }\n  }\n\n  protected isWebsocketReadyState = () => this._ws?.readyState === 1;\n\n  // protected addListener({\n  //   lis,\n  //   check,\n  // }: {\n  //   lis: (v: any) => any;\n  //   check: (v: any) => any;\n  //   groupKey?: string;\n  // }): { destroy: Function } {\n  //   this._ws.onmessage = (e: any) => {\n  //     const m = JSON.parse(e.data);\n\n  //     if (m?.error) {\n  //       lis(m);\n  //     } else if (check(m)) {\n  //       lis(m);\n  //     }\n  //   };\n\n  //   return\n  //     destroy: () => {},\n  //   };\n  // }\n\n  protected isInvalidAPIKey = () => {\n    return this._connectionError?.error?.code === \"invalidApiKey\";\n  };\n\n  protected addListener({\n    lis,\n    // check,\n    groupKey,\n    taskUUID,\n  }: {\n    lis: (v: any) => any;\n    // check: ETaskType;\n    groupKey?: string;\n    taskUUID: string;\n  }) {\n    const listener = (msg: {\n      data: any[];\n      errors?: { taskUUID: string; code: string; taskType?: string }[];\n      errorMessage?: string;\n    }) => {\n      const arrayMessage = Array.isArray(msg?.data) ? msg.data : [msg.data];\n\n      const arrayErrors = (msg as any)?.[0]?.errors\n        ? (msg as any)?.[0]?.errors\n        : Array.isArray(msg?.errors)\n        ? msg.errors\n        : [msg.errors];\n\n      const filteredMessage = arrayMessage.filter(\n        (v) => (v?.taskUUID || v?.taskType) === taskUUID\n      );\n\n      const filteredErrors = arrayErrors.filter(\n        (v: any) => (v?.taskUUID || v?.taskType) === taskUUID\n      );\n\n      if (filteredErrors.length) {\n        lis({ error: { ...(arrayErrors[0] ?? {}) } });\n        return;\n      }\n\n      if (filteredMessage.length) {\n        lis({ [taskUUID]: arrayMessage });\n        return;\n      }\n    };\n    const groupListener = { key: taskUUID || getUUID(), listener, groupKey };\n    this._listeners.push(groupListener);\n    const destroy = () => {\n      this._listeners = removeListener(this._listeners, groupListener);\n    };\n\n    return {\n      destroy,\n    };\n  }\n\n  protected connect() {\n    this._ws.onopen = (e: any) => {\n      if (this._connectionSessionUUID) {\n        this.send({\n          taskType: ETaskType.AUTHENTICATION,\n          apiKey: this._apiKey,\n          connectionSessionUUID: this._connectionSessionUUID,\n        });\n      } else {\n        this.send({ apiKey: this._apiKey, taskType: ETaskType.AUTHENTICATION });\n      }\n\n      this.addListener({\n        taskUUID: ETaskType.AUTHENTICATION,\n        lis: (m) => {\n          if (m?.error) {\n            this._connectionError = m;\n            return;\n          }\n          this._connectionSessionUUID =\n            m?.[ETaskType.AUTHENTICATION]?.[0]?.connectionSessionUUID;\n          this._connectionError = undefined;\n        },\n      });\n    };\n\n    this._ws.onmessage = (e: any) => {\n      const data = JSON.parse(e.data);\n      for (const lis of this._listeners) {\n        const result = (lis as any)?.listener?.(data);\n        if (result) return;\n      }\n    };\n\n    this._ws.onclose = (e: any) => {\n      // console.log(\"closing\");\n      // console.log(\"invalid\", this._invalidAPIkey);\n      if (this.isInvalidAPIKey()) {\n        return;\n      }\n    };\n  }\n\n  // We moving to an array format, it make sense to consolidate all request to an array here\n  protected send = (msg: Object) => {\n    this._ws.send(JSON.stringify([msg]));\n  };\n\n  private destroy(lis: any) {\n    removeFromAray(this._listeners, lis);\n  }\n\n  private uploadImage = async (\n    file: File | string\n  ): Promise<UploadImageType | null> => {\n    try {\n      return await asyncRetry(async () => {\n        const taskUUID = getUUID();\n\n        if (typeof file === \"string\" && isValidUUID(file)) {\n          return {\n            imageURL: file,\n            imageUUID: file,\n            taskUUID,\n            taskType: ETaskType.IMAGE_UPLOAD,\n          };\n        }\n\n        const imageBase64 =\n          typeof file === \"string\" ? file : await fileToBase64(file);\n\n        return {\n          imageURL: imageBase64,\n          imageUUID: imageBase64,\n          taskUUID,\n          taskType: ETaskType.IMAGE_UPLOAD,\n        };\n      });\n    } catch (e) {\n      throw e;\n    }\n  };\n\n  private listenToResponse({\n    onPartialImages,\n    taskUUID,\n    groupKey,\n    requestPayload,\n    startTime,\n  }: {\n    taskUUID: string;\n    onPartialImages?: (images: IImage[], error?: any) => void;\n    groupKey: LISTEN_TO_MEDIA_KEY;\n    requestPayload?: Record<string, any>;\n    startTime?: number;\n  }) {\n    return this.addListener({\n      taskUUID: taskUUID,\n      lis: (m) => {\n        let images = (m?.[taskUUID] as IImage[])?.filter(\n          (img) => img.taskUUID === taskUUID\n        );\n\n        if (m.error) {\n          onPartialImages?.(images, m?.error && m);\n          this._globalError = m;\n        } else {\n          images = images.map((image) => {\n            this.insertAdditionalResponse({\n              response: image,\n              payload: requestPayload ? requestPayload : undefined,\n              startTime: startTime ? startTime : undefined,\n            });\n\n            return {\n              ...image,\n            };\n          });\n          onPartialImages?.(images, m?.error && m);\n\n          if (this._sdkType === SdkType.CLIENT) {\n            // this._globalImages = [...this._globalImages, ...m.images];\n            this._globalImages = [\n              ...this._globalImages,\n              ...(m?.[taskUUID] ?? []).map((image: IImage) => {\n                this.insertAdditionalResponse({\n                  response: image,\n                  payload: requestPayload ? requestPayload : undefined,\n                  startTime: startTime ? startTime : undefined,\n                });\n\n                return {\n                  ...image,\n                };\n              }),\n            ];\n          } else {\n            this._globalImages = [...this._globalImages, ...images];\n          }\n        }\n      },\n      groupKey,\n    });\n  }\n\n  private listenToUpload({\n    onUploadStream,\n    taskUUID,\n  }: {\n    taskUUID: string;\n    onUploadStream?: (\n      addModelResponse?: IAddModelResponse,\n      error?: IErrorResponse\n    ) => void;\n  }) {\n    return this.addListener({\n      taskUUID: taskUUID,\n      lis: (m) => {\n        const error = m?.error;\n\n        const result = m?.[taskUUID]?.[0] as IAddModelResponse;\n        let response = result?.taskUUID === taskUUID ? result : null;\n\n        if (response || error) {\n          onUploadStream?.(response || undefined, error);\n        }\n      },\n    });\n  }\n\n  private globalListener({ taskUUID }: { taskUUID: string }) {\n    return this.addListener({\n      // check: (m) => {\n      //   const value = accessDeepObject({\n      //     key: responseKey,\n      //     data: m,\n      //     useZero: false,\n      //   });\n      //   return !!value;\n      // },\n      // check: responseKey,\n      taskUUID: taskUUID,\n      lis: (m) => {\n        if (m.error) {\n          this._globalMessages[taskUUID] = m;\n          return;\n        }\n\n        // console.log(\"m\", m);\n\n        const value = accessDeepObject({\n          key: taskUUID,\n          data: m,\n          useZero: false,\n        });\n        // console.log({ value });\n\n        if (Array.isArray(value)) {\n          value.forEach((v) => {\n            this._globalMessages[v.taskUUID] = [\n              ...(this._globalMessages[v.taskUUID] ?? []),\n              v,\n            ];\n          });\n        } else {\n          this._globalMessages[value.taskUUID] = value;\n        }\n      },\n    });\n  }\n\n  // includePayload?: boolean\n  // includeGenerationTime?: boolean\n\n  async requestImages(\n    {\n      outputType,\n      outputFormat,\n      uploadEndpoint,\n      checkNSFW,\n      positivePrompt,\n      negativePrompt,\n      seedImage,\n      maskImage,\n      strength,\n      height,\n      width,\n      model,\n      steps,\n      scheduler,\n      seed,\n      CFGScale,\n      clipSkip,\n      usePromptWeighting,\n      promptWeighting,\n      numberResults = 1,\n      onPartialImages,\n      includeCost,\n      customTaskUUID,\n      taskUUID: _taskUUID,\n      retry,\n      refiner,\n      maskMargin,\n      outputQuality,\n      controlNet,\n      lora,\n      embeddings,\n      ipAdapters,\n      providerSettings,\n      outpaint,\n      acceleratorOptions,\n      advancedFeatures,\n      referenceImages,\n      includeGenerationTime,\n      includePayload,\n      ...rest\n    }: // imageSize,\n    // gScale,\n    IRequestImage,\n    moreOptions?: Record<string, any>\n  ): Promise<ITextToImage[] | undefined> {\n    let lis: any = undefined;\n    let requestObject: Record<string, any> | undefined = undefined;\n    let taskUUIDs: string[] = [];\n    let retryCount = 0;\n\n    const totalRetry = retry || this._globalMaxRetries;\n\n    try {\n      await this.ensureConnection();\n\n      let seedImageUUID: string | null = null;\n      let maskImageUUID: string | null = null;\n      let controlNetData: IControlNetWithUUID[] = [];\n\n      if (seedImage) {\n        const uploadedImage = await this.uploadImage(seedImage);\n\n        if (!uploadedImage) return [];\n        seedImageUUID = uploadedImage.imageUUID;\n      }\n      if (maskImage) {\n        const uploadedMaskInitiator = await this.uploadImage(maskImage);\n        if (!uploadedMaskInitiator) return [];\n        maskImageUUID = uploadedMaskInitiator.imageUUID;\n      }\n\n      if (controlNet?.length) {\n        for (let i = 0; i < controlNet.length; i++) {\n          const controlData: IControlNet = controlNet[i];\n          const {\n            endStep,\n            startStep,\n            weight,\n            guideImage,\n            controlMode,\n            startStepPercentage,\n            endStepPercentage,\n            model: controlNetModel,\n          } = controlData;\n\n          const imageUploaded = guideImage\n            ? await this.uploadImage(guideImage as File | string)\n            : null;\n\n          controlNetData.push({\n            guideImage: imageUploaded?.imageUUID,\n            model: controlNetModel,\n            endStep,\n            startStep,\n            weight,\n            ...evaluateNonTrue({\n              key: \"startStepPercentage\",\n              value: startStepPercentage,\n            }),\n            ...evaluateNonTrue({\n              key: \"endStepPercentage\",\n              value: endStepPercentage,\n            }),\n            controlMode: controlMode || EControlMode.CONTROL_NET,\n          });\n        }\n      }\n\n      requestObject = {\n        taskType: ETaskType.IMAGE_INFERENCE,\n        model,\n        positivePrompt: positivePrompt,\n        ...(negativePrompt ? { negativePrompt } : {}),\n        ...(height ? { height } : {}),\n        ...(width ? { width } : {}),\n        numberResults,\n\n        ...(outputType ? { outputType } : {}),\n        ...(outputFormat ? { outputFormat } : {}),\n        ...(uploadEndpoint ? { uploadEndpoint } : {}),\n        ...evaluateNonTrue({ key: \"checkNSFW\", value: checkNSFW }),\n        ...evaluateNonTrue({ key: \"strength\", value: strength }),\n        ...evaluateNonTrue({ key: \"CFGScale\", value: CFGScale }),\n        ...evaluateNonTrue({ key: \"clipSkip\", value: clipSkip }),\n        ...evaluateNonTrue({ key: \"maskMargin\", value: maskMargin }),\n        ...evaluateNonTrue({\n          key: \"usePromptWeighting\",\n          value: usePromptWeighting,\n        }),\n        ...evaluateNonTrue({ key: \"steps\", value: steps }),\n        ...(promptWeighting ? { promptWeighting } : {}),\n        ...(seed ? { seed: seed } : {}),\n        ...(scheduler ? { scheduler } : {}),\n        ...(refiner ? { refiner } : {}),\n        ...(outpaint ? { outpaint } : {}),\n        ...evaluateNonTrue({ key: \"includeCost\", value: includeCost }),\n        ...(seedImageUUID ? { seedImage: seedImageUUID } : {}),\n        ...(maskImageUUID ? { maskImage: maskImageUUID } : {}),\n        ...(outputQuality ? { outputQuality } : {}),\n        ...(controlNetData.length ? { controlNet: controlNetData } : {}),\n        ...(lora?.length ? { lora: lora } : {}),\n        ...(embeddings?.length ? { embeddings } : {}),\n        ...(ipAdapters?.length ? { ipAdapters } : {}),\n        ...(providerSettings ? { providerSettings } : {}),\n        ...(acceleratorOptions ? { acceleratorOptions } : {}),\n        ...(advancedFeatures ? { advancedFeatures } : {}),\n        ...(referenceImages?.length ? { referenceImages } : {}),\n        ...rest,\n        ...(moreOptions ?? {}),\n      };\n\n      const startTime = Date.now();\n\n      return await asyncRetry(\n        async () => {\n          retryCount++;\n          lis?.destroy();\n          const imagesWithSimilarTask = this._globalImages.filter((img) =>\n            taskUUIDs.includes(img.taskUUID)\n          );\n\n          const taskUUID = _taskUUID || customTaskUUID || getUUID();\n\n          taskUUIDs.push(taskUUID);\n\n          const imageRemaining = numberResults - imagesWithSimilarTask.length;\n\n          const newRequestObject = {\n            ...requestObject,\n            taskUUID: taskUUID,\n            numberResults: imageRemaining,\n          };\n          this.send(newRequestObject);\n\n          // const generationTime = endTime - startTime;\n\n          lis = this.listenToResponse({\n            onPartialImages,\n            taskUUID: taskUUID,\n            groupKey: LISTEN_TO_MEDIA_KEY.REQUEST_IMAGES,\n            requestPayload: includePayload ? newRequestObject : undefined,\n            startTime: includeGenerationTime ? startTime : undefined,\n          });\n\n          const promise = await this.getResponseWithSimilarTaskUUID({\n            taskUUID: taskUUIDs,\n            numberResults,\n            lis,\n            deliveryMethod: rest.deliveryMethod\n          });\n\n          lis.destroy();\n\n          return promise;\n        },\n        {\n          maxRetries: totalRetry,\n          callback: () => {\n            lis?.destroy();\n          },\n        }\n      );\n    } catch (e) {\n      if (retryCount >= totalRetry) {\n        return this.handleIncompleteImages({ taskUUIDs, error: e });\n      }\n      throw e;\n    }\n  }\n\n  // Alias for requestImages\n  async imageInference(\n    params: IRequestImage,\n    moreOptions?: Record<string, any>\n  ): Promise<ITextToImage[] | undefined> {\n    return this.requestImages(params, moreOptions);\n  }\n\n  controlNetPreProcess = async ({\n    inputImage,\n    preProcessorType,\n    height,\n    width,\n    outputType,\n    outputFormat,\n    highThresholdCanny,\n    lowThresholdCanny,\n    includeHandsAndFaceOpenPose,\n    includeCost,\n    outputQuality,\n    customTaskUUID,\n    taskUUID: _taskUUID,\n    retry,\n    includeGenerationTime,\n    includePayload,\n  }: IControlNetPreprocess): Promise<IControlNetImage | null> => {\n    const totalRetry = retry || this._globalMaxRetries;\n    let lis: any = undefined;\n\n    const startTime = Date.now();\n\n    try {\n      return await asyncRetry(\n        async () => {\n          await this.ensureConnection();\n          const image = await this.uploadImage(inputImage);\n          if (!image?.imageUUID) return null;\n\n          const taskUUID = _taskUUID || customTaskUUID || getUUID();\n          const payload = {\n            inputImage: image.imageUUID,\n            taskType: ETaskType.IMAGE_CONTROL_NET_PRE_PROCESS,\n            taskUUID,\n            preProcessorType,\n            ...evaluateNonTrue({ key: \"height\", value: height }),\n            ...evaluateNonTrue({ key: \"width\", value: width }),\n            ...evaluateNonTrue({ key: \"outputType\", value: outputType }),\n            ...evaluateNonTrue({ key: \"outputFormat\", value: outputFormat }),\n            ...evaluateNonTrue({ key: \"includeCost\", value: includeCost }),\n            ...evaluateNonTrue({\n              key: \"highThresholdCanny\",\n              value: highThresholdCanny,\n            }),\n            ...evaluateNonTrue({\n              key: \"lowThresholdCanny\",\n              value: lowThresholdCanny,\n            }),\n            ...evaluateNonTrue({\n              key: \"includeHandsAndFaceOpenPose\",\n              value: includeHandsAndFaceOpenPose,\n            }),\n            ...(outputQuality ? { outputQuality } : {}),\n          };\n\n          this.send({\n            ...payload,\n          });\n          lis = this.globalListener({\n            taskUUID,\n          });\n\n          const guideImage = (await getIntervalWithPromise(\n            ({ resolve, reject }) => {\n              const uploadedImage = this.getSingleMessage({\n                taskUUID,\n              });\n\n              if (!uploadedImage) return;\n\n              if (uploadedImage?.error) {\n                reject(uploadedImage);\n                return true;\n              }\n\n              if (uploadedImage) {\n                // delete this._globalMessages[taskUUID];\n                resolve(uploadedImage);\n                return true;\n              }\n            },\n            {\n              debugKey: \"unprocessed-image\",\n              timeoutDuration: this._timeoutDuration,\n            }\n          )) as IControlNetImage;\n\n          lis.destroy();\n\n          this.insertAdditionalResponse({\n            response: guideImage,\n            payload: includePayload ? payload : undefined,\n            startTime: includeGenerationTime ? startTime : undefined,\n          });\n\n          return guideImage;\n        },\n        {\n          maxRetries: totalRetry,\n          callback: () => {\n            lis?.destroy();\n          },\n        }\n      );\n    } catch (e: any) {\n      throw e;\n    }\n  };\n\n  // Alias for controlNetPreProcess\n  controlNetPreprocess = async (\n    params: IControlNetPreprocess\n  ): Promise<IControlNetImage | null> => {\n    return this.controlNetPreProcess(params);\n  };\n\n  requestImageToText = async ({\n    inputImage,\n    inputs,\n    includeCost,\n    customTaskUUID,\n    taskUUID: _taskUUID,\n    retry,\n    includePayload,\n    includeGenerationTime,\n    deliveryMethod,\n    skipResponse,\n    model,\n  }: IRequestImageToText): Promise<IImageToText> => {\n    try {\n      let imageUploaded;\n\n      // TODO: Add support for handling all media uploads from inputs object\n      // This is legacy support for inputImage only\n      if (inputImage) {\n        imageUploaded = await this.uploadImage(inputImage as File | string);\n      }\n\n      const taskUUID = _taskUUID || customTaskUUID || getUUID();\n      const payload = {\n        taskUUID,\n        taskType: ETaskType.CAPTION,\n        model,\n        inputImage: imageUploaded?.imageUUID,\n        inputs,\n        ...evaluateNonTrue({ key: \"includeCost\", value: includeCost }),\n        retry,\n        includePayload,\n        includeGenerationTime,\n      };\n\n      const request = await this.baseSingleRequest<IImageToText>({\n        payload: {\n          ...payload,\n          taskType: ETaskType.CAPTION,\n        },\n        debugKey: \"caption\",\n      });\n\n      if (skipResponse) {\n        return request;\n      }\n\n      if (deliveryMethod === \"async\") {\n        const taskUUID = request?.taskUUID;\n        const results = await this.pollForAsyncResults<IImageToText>({\n          taskUUID,\n        });\n        return results[0];\n      }\n\n      return request;\n    } catch (e) {\n      throw e;\n    }\n  };\n\n  // Alias for requestImageToText\n  caption = async (params: IRequestImageToText): Promise<IImageToText> => {\n    return this.requestImageToText(params);\n  };\n\n  /**\n   * Remove the background from an image or video.\n   * @remark This method now supports the removeBackground type which can handle multiple media types such as image and video.\n   * If you pass an `inputs` object with `inputs.image` or `inputs.video`, the response will contain `mediaUUID` and `mediaURL`.\n   * If you pass `inputImage`, the response will contain `imageUUID` and `imageURL`.\n   * @remark `imageUUID` is no longer guaranteed in the response. Use `mediaUUID` for new implementations.\n   * @since 1.2.0\n   * @returns {Promise<IRemoveImage>} If called with `inputs.image` or `inputs.video`, returns an object with `mediaUUID` and `mediaURL`. If called with `inputImage`, returns an object with `imageUUID` and `imageURL` (not guaranteed).\n   */\n  removeImageBackground = async (\n    payload: IRemoveImageBackground\n  ): Promise<IRemoveImage> => {\n    const { skipResponse, ...rest } = payload;\n\n    try {\n      const deliveryMethod = rest.deliveryMethod;\n      const request = await this.baseSingleRequest<IRemoveImage>({\n        payload: {\n          ...rest,\n          taskType: ETaskType.REMOVE_BACKGROUND,\n        },\n        debugKey: \"remove-background\",\n      });\n\n      if (skipResponse) {\n        return request;\n      }\n\n      if (deliveryMethod === \"async\") {\n        const taskUUID = request?.taskUUID;\n        const results = await this.pollForAsyncResults<IRemoveImage>({\n          taskUUID,\n        });\n        return results[0];\n      }\n\n      // If not async, just return the initial result\n      return request;\n    } catch (e) {\n      throw e;\n    }\n  };\n\n  // Alias for removeImageBackground\n  removeBackground = async (\n    payload: IRemoveImageBackground\n  ): Promise<IRemoveImage> => {\n    return this.removeImageBackground(payload);\n  };\n\n  vectorize = async (payload: TVectorize): Promise<TVectorizeResponse> => {\n    return this.baseSingleRequest({\n      payload: {\n        ...payload,\n        taskType: ETaskType.VECTORIZE,\n      },\n      debugKey: \"vectorize\",\n    });\n  };\n\n  videoInference = async (\n    payload: IRequestVideo\n  ): Promise<IVideoToImage[] | IVideoToImage> => {\n    const { skipResponse, inputAudios, referenceVideos, ...rest } = payload;\n    try {\n      const request = await this.baseSingleRequest<IVideoToImage>({\n        payload: {\n          ...rest,\n          ...(inputAudios?.length && { inputAudios }),\n          ...(referenceVideos?.length && { referenceVideos }),\n          deliveryMethod: \"async\",\n          taskType: ETaskType.VIDEO_INFERENCE,\n        },\n\n        debugKey: \"video-inference\",\n      });\n\n      if (skipResponse) {\n        return request;\n      }\n\n      const taskUUID = request?.taskUUID;\n      return this.pollForAsyncResults({\n        taskUUID,\n        numberResults: payload?.numberResults,\n      });\n    } catch (e) {\n      throw e;\n    }\n  };\n\n  audioInference = async (\n    payload: IRequestAudio\n  ): Promise<IAudio[] | IAudio> => {\n    const { skipResponse, deliveryMethod = \"sync\", ...rest } = payload;\n\n    try {\n      const requestMethod =\n        deliveryMethod === \"sync\"\n          ? this.baseSyncRequest\n          : this.baseSingleRequest;\n\n      const request = await requestMethod<IAudio>({\n        payload: {\n          ...rest,\n          numberResults: rest.numberResults || 1,\n          taskType: ETaskType.AUDIO_INFERENCE,\n          deliveryMethod: deliveryMethod,\n        },\n        groupKey: LISTEN_TO_MEDIA_KEY.REQUEST_AUDIO,\n        debugKey: \"audio-inference\",\n        skipResponse\n      });\n\n\n      if (skipResponse) {\n        return request;\n      }\n\n      const taskUUID = request?.taskUUID;\n      if (deliveryMethod === \"async\") {\n        return this.pollForAsyncResults<IAudio>({\n          taskUUID,\n          numberResults: payload?.numberResults,\n        });\n      }\n\n      // If not async, just return the initial result\n      return request;\n    } catch (e) {\n      throw e;\n    }\n  };\n\n  getResponse = async <T>(payload: IAsyncResults): Promise<T[]> => {\n    const taskUUID = payload.taskUUID;\n    // const mock = getRandomTaskResponses({ count: 2, taskUUID });\n    return this.baseSingleRequest({\n      payload: {\n        ...payload,\n        customTaskUUID: taskUUID,\n        taskType: ETaskType.GET_RESPONSE,\n      },\n      isMultiple: true,\n      debugKey: \"async-results\",\n    });\n  };\n\n  /**\n   * Upscale an image or video\n   * @remark This method now supports the upscale type which can handle multiple media types such as image and video.\n   * If you pass an `inputs` object with `inputs.image` or `inputs.video`, the response will contain `mediaUUID` and `mediaURL`.\n   * If you pass `inputImage`, the response will contain `imageUUID` and `imageURL`.\n   * @remark `imageUUID` is no longer guaranteed in the response. Use `mediaUUID` for new implementations.\n   * @since 1.2.0\n   * @returns {Promise<IImage>} If called with `inputs.image` or `inputs.video`, returns an object with `mediaUUID` and `mediaURL`. If called with `inputImage`, returns an object with `imageUUID` and `imageURL` (not guaranteed).\n   */\n  upscaleGan = async ({\n    inputImage,\n    inputs,\n    model,\n    upscaleFactor,\n    outputType,\n    outputFormat,\n    includeCost,\n    outputQuality,\n    customTaskUUID,\n    taskUUID: _taskUUID,\n    retry,\n    includeGenerationTime,\n    includePayload,\n    skipResponse,\n    deliveryMethod\n  }: IUpscaleGan): Promise<IImage> => {\n    try {\n      let imageUploaded;\n\n      // TODO: Add support for handling all media uploads from inputs object\n      // This is legacy support for inputImage only\n      if (inputImage) {\n        imageUploaded = await this.uploadImage(inputImage as File | string);\n      }\n\n      const taskUUID = _taskUUID || customTaskUUID || getUUID();\n      const payload = {\n        taskUUID,\n        inputImage: imageUploaded?.imageUUID,\n        taskType: ETaskType.UPSCALE,\n        inputs,\n        model,\n        upscaleFactor,\n        ...evaluateNonTrue({ key: \"includeCost\", value: includeCost }),\n        ...(outputType ? { outputType } : {}),\n        ...(outputQuality ? { outputQuality } : {}),\n        ...(outputFormat ? { outputFormat } : {}),\n        includePayload,\n        includeGenerationTime,\n        retry,\n        deliveryMethod\n      };\n\n      const request = await this.baseSingleRequest<IImage>({\n        payload: {\n          ...payload,\n          taskType: ETaskType.UPSCALE,\n        },\n        debugKey: \"upscale\",\n      });\n\n      if (skipResponse) {\n        return request;\n      }\n\n      if (deliveryMethod === \"async\") {\n        const taskUUID = request?.taskUUID;\n        const results = await this.pollForAsyncResults<IImage>({\n          taskUUID,\n        });\n        return results[0];\n      }\n\n      // If not async, just return the initial result\n      return request;\n    } catch (e) {\n      throw e;\n    }\n  };\n\n\n  // Alias for upscaleGan\n  upscale = async (params: IUpscaleGan): Promise<IImage> => {\n    return this.upscaleGan(params);\n  };\n\n  enhancePrompt = async ({\n    prompt,\n    promptMaxLength = 380,\n    promptVersions = 1,\n    includeCost,\n    customTaskUUID,\n    taskUUID: _taskUUID,\n    retry,\n    includeGenerationTime,\n    includePayload,\n  }: IPromptEnhancer): Promise<IEnhancedPrompt[]> => {\n    const totalRetry = retry || this._globalMaxRetries;\n    let lis: any = undefined;\n\n    const startTime = Date.now();\n\n    try {\n      return await asyncRetry(\n        async () => {\n          await this.ensureConnection();\n          const taskUUID = _taskUUID || customTaskUUID || getUUID();\n\n          const payload = {\n            prompt,\n            taskUUID,\n            promptMaxLength,\n            promptVersions,\n            ...evaluateNonTrue({ key: \"includeCost\", value: includeCost }),\n            taskType: ETaskType.PROMPT_ENHANCE,\n          };\n\n          this.send(payload);\n\n          lis = this.globalListener({\n            taskUUID,\n          });\n\n          const response = await getIntervalWithPromise(\n            ({ resolve, reject }) => {\n              const reducedPrompt: IEnhancedPrompt[] =\n                this._globalMessages[taskUUID];\n\n              if ((reducedPrompt as any)?.error) {\n                reject(reducedPrompt as any);\n                return true;\n              }\n\n              if (reducedPrompt?.length >= promptVersions) {\n                delete this._globalMessages[taskUUID];\n                resolve(reducedPrompt);\n                return true;\n              }\n            },\n            {\n              debugKey: \"enhance-prompt\",\n              timeoutDuration: this._timeoutDuration,\n            }\n          );\n\n          lis.destroy();\n\n          this.insertAdditionalResponse({\n            response: response,\n            payload: includePayload ? payload : undefined,\n            startTime: includeGenerationTime ? startTime : undefined,\n          });\n          return response as IEnhancedPrompt[];\n        },\n        {\n          maxRetries: totalRetry,\n          callback: () => {\n            lis?.destroy();\n          },\n        }\n      );\n    } catch (e) {\n      throw e;\n    }\n  };\n\n  // Alias for enhancePrompt\n  promptEnhance = async (\n    params: IPromptEnhancer\n  ): Promise<IEnhancedPrompt[]> => {\n    return this.enhancePrompt(params);\n  };\n\n  modelUpload = async (payload: TAddModel) => {\n    // This is written to destructure the payload from the additional parameters\n    const {\n      onUploadStream,\n      retry,\n      customTaskUUID,\n      taskUUID: _taskUUID,\n      ...addModelPayload\n    } = payload;\n\n    const totalRetry = retry || this._globalMaxRetries;\n    let lis: any = undefined;\n\n    try {\n      return await asyncRetry(\n        async () => {\n          await this.ensureConnection();\n          const taskUUID = _taskUUID || customTaskUUID || getUUID();\n\n          this.send({\n            ...addModelPayload,\n            taskUUID,\n            taskType: ETaskType.MODEL_UPLOAD,\n          });\n\n          let result: IAddModelResponse;\n          let errorResult: IErrorResponse;\n\n          lis = this.listenToUpload({\n            taskUUID,\n            onUploadStream: (response, error) => {\n              onUploadStream?.(response, error);\n              if (response?.status === \"ready\") {\n                result = response;\n              } else if (error) {\n                errorResult = error;\n              }\n            },\n          });\n\n          const modelUploadResponse = await getIntervalWithPromise(\n            ({ resolve, reject }) => {\n              if (result) {\n                resolve(result);\n                return true;\n              } else if (errorResult) {\n                reject(errorResult);\n                return false;\n              }\n            },\n            {\n              shouldThrowError: false,\n              timeoutDuration: 60 * 60 * 1000,\n            }\n          );\n\n          return modelUploadResponse as IAddModelResponse | IErrorResponse;\n        },\n        {\n          maxRetries: totalRetry,\n          callback: () => {\n            lis?.destroy();\n          },\n        }\n      );\n    } catch (e) {\n      throw e;\n    }\n  };\n\n  photoMaker = async (\n    payload: TPhotoMaker,\n    moreOptions?: Record<string, any>\n  ): Promise<TPhotoMakerResponse[] | undefined> => {\n    // This is written to destructure the payload from the additional parameters\n    const {\n      onPartialImages,\n      retry,\n      customTaskUUID,\n      taskUUID: _taskUUID,\n      numberResults,\n      includeGenerationTime,\n      includePayload,\n      ...photoMakerPayload\n    } = payload;\n\n    const totalRetry = retry || this._globalMaxRetries;\n    let lis: any = undefined;\n    let taskUUIDs: string[] = [];\n    let retryCount = 0;\n\n    const startTime = Date.now();\n\n    try {\n      return await asyncRetry(\n        async () => {\n          await this.ensureConnection();\n          retryCount++;\n          const imagesWithSimilarTask = this._globalImages.filter((img) =>\n            taskUUIDs.includes(img.taskUUID)\n          );\n\n          const taskUUID = _taskUUID || customTaskUUID || getUUID();\n          taskUUIDs.push(taskUUID);\n\n          const imageRemaining = numberResults - imagesWithSimilarTask.length;\n\n          const payload = {\n            ...photoMakerPayload,\n            ...(photoMakerPayload.seed\n              ? { seed: photoMakerPayload.seed }\n              : { seed: getRandomSeed() }),\n            ...(moreOptions ?? {}),\n            taskUUID,\n            taskType: ETaskType.PHOTO_MAKER,\n            numberResults,\n          };\n\n          this.send({\n            ...payload,\n            numberResults: imageRemaining,\n          });\n\n          lis = this.listenToResponse({\n            onPartialImages,\n            taskUUID: taskUUID,\n            groupKey: LISTEN_TO_MEDIA_KEY.REQUEST_IMAGES,\n            requestPayload: includePayload ? payload : undefined,\n            startTime: includeGenerationTime ? startTime : undefined,\n          });\n\n          const promise = await this.getResponseWithSimilarTaskUUID({\n            taskUUID: taskUUIDs,\n            numberResults,\n            lis,\n          });\n\n          lis.destroy();\n\n          return promise as TPhotoMakerResponse[];\n        },\n        {\n          maxRetries: totalRetry,\n          callback: () => {\n            lis?.destroy();\n          },\n        }\n      );\n    } catch (e) {\n      if ((e as any).taskUUID) {\n        throw e;\n      }\n      if (retryCount >= totalRetry) {\n        return this.handleIncompleteImages({\n          taskUUIDs,\n          error: e,\n        }) as TPhotoMakerResponse[];\n      }\n    }\n  };\n\n  modelSearch = async (\n    payload: TModelSearch\n  ): Promise<TModelSearchResponse> => {\n    return this.baseSingleRequest({\n      payload: {\n        ...payload,\n        taskType: ETaskType.MODEL_SEARCH,\n      },\n      debugKey: \"model-search\",\n    });\n  };\n\n  imageMasking = async (\n    payload: TImageMasking\n  ): Promise<TImageMaskingResponse> => {\n    return this.baseSingleRequest({\n      payload: {\n        ...payload,\n        taskType: ETaskType.IMAGE_MASKING,\n      },\n      debugKey: \"image-masking\",\n    });\n  };\n\n  imageUpload = async (\n    payload: TImageUpload\n  ): Promise<TImageUploadResponse> => {\n    return this.baseSingleRequest({\n      payload: {\n        ...payload,\n        taskType: ETaskType.IMAGE_UPLOAD,\n      },\n      debugKey: \"image-upload\",\n    });\n  };\n\n  mediaStorage = async (\n    payload: TMediaStorage\n  ): Promise<TMediaStorageResponse> => {\n    return this.baseSingleRequest({\n      payload: {\n        ...payload,\n        operation: payload.operation || \"upload\",\n        taskType: ETaskType.MEDIA_STORAGE,\n      },\n      debugKey: \"media-storage\",\n    });\n  };\n\n  protected baseSingleRequest = async <T>({\n    payload,\n    debugKey,\n    isMultiple,\n  }: {\n    payload: Record<string, any>;\n    debugKey: string;\n    isMultiple?: boolean;\n  }): Promise<T> => {\n    const {\n      retry,\n      customTaskUUID,\n      taskUUID: _taskUUID,\n      includePayload,\n      includeGenerationTime,\n      ...restPayload\n    } = payload;\n\n    const totalRetry = retry || this._globalMaxRetries;\n    let lis: any = undefined;\n\n    const startTime = Date.now();\n\n    try {\n      return await asyncRetry(\n        async () => {\n          await this.ensureConnection();\n          const taskUUID = _taskUUID || customTaskUUID || getUUID();\n          const payload = {\n            ...restPayload,\n            taskUUID,\n          };\n\n          this.send(payload);\n\n          lis = this.globalListener({\n            taskUUID,\n          });\n\n          const response = await getIntervalWithPromise(\n            ({ resolve, reject }) => {\n              // console.log(\"multiple\", isMultiple);\n              const response = isMultiple\n                ? this.getMultipleMessages({ taskUUID })\n                : this.getSingleMessage({ taskUUID });\n              if (!response) return;\n\n              if (response?.error) {\n                reject(response);\n                return true;\n              }\n\n              if (response) {\n                delete this._globalMessages[taskUUID];\n                resolve(response);\n                return true;\n              }\n            },\n            {\n              debugKey,\n              timeoutDuration: this._timeoutDuration,\n            }\n          );\n\n          this.insertAdditionalResponse({\n            response: response,\n            payload: includePayload ? payload : undefined,\n            startTime: includeGenerationTime ? startTime : undefined,\n          });\n\n          lis.destroy();\n          return response as T;\n        },\n        {\n          maxRetries: totalRetry,\n          callback: () => {\n            lis?.destroy();\n          },\n        }\n      );\n    } catch (e) {\n      throw e;\n    }\n  };\n\n  protected baseSyncRequest = async <T>({\n    payload,\n    groupKey,\n    skipResponse = false\n  }: {\n    payload: Record<string, any>;\n    groupKey: LISTEN_TO_MEDIA_KEY;\n    skipResponse?: boolean;\n  }): Promise<T> => {\n    const {\n      retry,\n      customTaskUUID,\n      includePayload,\n      numberResults = 1,\n      onPartialResponse,\n      includeGenerationTime,\n      ...restPayload\n    } = payload;\n\n    const totalRetry = retry || this._globalMaxRetries;\n    let lis: any = undefined;\n    let taskUUIDs: string[] = [];\n    let retryCount = 0;\n\n    const startTime = Date.now();\n\n    try {\n      return await asyncRetry(\n        async () => {\n          await this.ensureConnection();\n          retryCount++;\n\n          const taskWithSimilarTaskUUID = this._globalImages.filter((audio) =>\n            taskUUIDs.includes(audio.taskUUID)\n          );\n\n          const taskUUID = customTaskUUID || getUUID();\n          taskUUIDs.push(taskUUID);\n          const taskRemaining = numberResults - taskWithSimilarTaskUUID.length;\n\n          const payload = {\n            ...restPayload,\n            taskUUID,\n            numberResults: taskRemaining,\n          };\n\n          this.send(payload);\n\n          if (skipResponse) {\n            return new Promise<T>((resolve, reject) => {\n              const listener = this.addListener({\n                taskUUID,\n                groupKey,\n                lis: (msg) => {\n                  listener.destroy();\n                  if (msg.error) {\n                    reject(msg.error);\n                  } else {\n                    resolve(msg[taskUUID]);\n                  }\n                },\n              });\n            });\n          };\n\n          lis = this.listenToResponse({\n            onPartialImages: onPartialResponse,\n            taskUUID: taskUUID,\n            groupKey,\n            requestPayload: includePayload ? payload : undefined,\n            startTime: includeGenerationTime ? startTime : undefined,\n          });\n\n          const promise = await this.getResponseWithSimilarTaskUUID({\n            taskUUID: taskUUIDs,\n            numberResults,\n            lis,\n            // debugKey,\n          });\n\n          lis.destroy();\n          return promise as T;\n        },\n        {\n          maxRetries: totalRetry,\n          callback: () => {\n            lis?.destroy();\n          },\n        }\n      );\n    } catch (e) {\n      throw e;\n    }\n  };\n\n  async ensureConnection() {\n    let isConnected = this.connected();\n    if (isConnected || this._url === BASE_RUNWARE_URLS.TEST) return;\n\n    const retryInterval = 2000;\n    const pollingInterval = 200;\n    // const pollingInterval = this._sdkType === SdkType.CLIENT ? 200 : 2000;\n\n    try {\n      if (this.isInvalidAPIKey()) {\n        throw this._connectionError;\n      }\n\n      return new Promise((resolve, reject) => {\n        //  const isConnected =\n        let retry = 0;\n        const MAX_RETRY = 30;\n\n        const localConnectionUUID = getUUID();\n\n        let retryIntervalId: any;\n        let pollingIntervalId: any;\n\n        const clearAllIntervals = () => {\n          this.ensureConnectionUUID = null;\n          clearInterval(retryIntervalId);\n          clearInterval(pollingIntervalId);\n        };\n\n        if (this._sdkType === SdkType.SERVER) {\n          retryIntervalId = setInterval(async () => {\n            try {\n              const hasConnected = this.connected();\n\n              // only one instance should be responsible for making the call again, not other ensureConnection\n              let shouldCallServer = false;\n\n              if (\n                !this.ensureConnectionUUID ||\n                localConnectionUUID === this.ensureConnectionUUID\n              ) {\n                if (!this.ensureConnectionUUID) {\n                  this.ensureConnectionUUID = localConnectionUUID;\n                }\n                shouldCallServer = true;\n              }\n\n              // Retry every (retryInterval % retry) => 60s\n              // every 20 seconds (ie. => retry is 10 (20s), retry is 20 (40s))\n              const SHOULD_RETRY = retry % 10 === 0 && shouldCallServer;\n\n              if (hasConnected) {\n                clearAllIntervals();\n                resolve(true);\n              } else if (retry >= MAX_RETRY) {\n                clearAllIntervals();\n                reject(new Error(\"Retry timed out\"));\n              } else {\n                if (SHOULD_RETRY) {\n                  this.connect();\n                }\n                retry++;\n              }\n            } catch (error) {\n              clearAllIntervals();\n              reject(error);\n            }\n          }, retryInterval);\n        }\n\n        pollingIntervalId = setInterval(async () => {\n          const hasConnected = this.connected();\n\n          if (hasConnected) {\n            clearAllIntervals();\n            resolve(true);\n            return;\n          }\n          if (!!this.isInvalidAPIKey()) {\n            clearAllIntervals();\n            reject(this._connectionError);\n            return;\n          }\n        }, pollingInterval);\n      });\n    } catch (e) {\n      this.ensureConnectionUUID = null;\n      this._connectionError = undefined;\n\n      throw (\n        this._connectionError ??\n        \"Could not connect to server. Ensure your API key is correct\"\n      );\n    }\n  }\n\n  private async getResponseWithSimilarTaskUUID({\n    taskUUID,\n    numberResults,\n    shouldThrowError,\n    lis,\n    deliveryMethod\n  }: {\n    taskUUID: string | string[];\n    numberResults: number;\n    shouldThrowError?: boolean;\n    lis: any;\n    deliveryMethod?: \"sync\" | \"async\";\n  }): Promise<IImage[] | IError> {\n    return (await getIntervalWithPromise(\n      ({ resolve, reject, intervalId }) => {\n        const taskUUIDs = Array.isArray(taskUUID) ? taskUUID : [taskUUID];\n        const imagesWithSimilarTask = this._globalImages.filter((img) =>\n          taskUUIDs.includes(img.taskUUID)\n        );\n\n        const isAsyncResponse = deliveryMethod === \"async\" && imagesWithSimilarTask.length > 0;\n\n        if (this._globalError) {\n          const newData = this._globalError;\n          this._globalError = undefined;\n          // throw errorData[0]\n          clearInterval(intervalId);\n          reject<IError>?.(newData);\n          return true;\n        }\n        // onPartialImages?.(imagesWithSimilarTask)\n        else if (imagesWithSimilarTask.length >= numberResults || isAsyncResponse) {\n          // lis?.destroy();\n          clearInterval(intervalId);\n          this._globalImages = this._globalImages.filter(\n            (img) => !taskUUIDs.includes(img.taskUUID)\n          );\n          resolve<IImage[]>([...imagesWithSimilarTask].slice(0, numberResults));\n          return true;\n          // Resolve the promise with the data\n        }\n      },\n      {\n        debugKey: \"getting images\",\n        shouldThrowError,\n        timeoutDuration: this._timeoutDuration,\n      }\n    )) as IImage[];\n  }\n\n  private getSingleMessage = ({ taskUUID }: { taskUUID: string }) => {\n    const value = this._globalMessages[taskUUID]?.[0];\n    const errorValue = this._globalMessages[taskUUID];\n    if (!value && !errorValue) return null;\n    return errorValue?.error ? errorValue : value;\n  };\n  private getMultipleMessages = ({ taskUUID }: { taskUUID: string }) => {\n    // console.log(\"global\", this._globalMessages);\n    const value = this._globalMessages[taskUUID]?.[0];\n    const mainValue = this._globalMessages[taskUUID];\n    if (!value && !mainValue) return null;\n    return mainValue;\n  };\n\n  private insertAdditionalResponse = <T>({\n    response,\n    payload,\n    startTime,\n  }: {\n    response: T;\n    payload?: Record<string, any>;\n    startTime?: number;\n  }) => {\n    if (!payload && !startTime) return;\n    const res = response as any;\n    res.additionalResponse = {};\n\n    if (!!payload) {\n      (response as any).additionalResponse.payload = payload;\n    }\n    if (!!startTime) {\n      (response as any).additionalResponse.generationTime =\n        Date.now() - startTime;\n    }\n  };\n\n  private handleIncompleteImages({\n    taskUUIDs,\n    error,\n  }: {\n    taskUUIDs: string[];\n    error: any;\n  }) {\n    const imagesWithSimilarTask = this._globalImages.filter((img) =>\n      taskUUIDs.includes(img.taskUUID)\n    );\n    if (imagesWithSimilarTask.length > 1) {\n      this._globalImages = this._globalImages.filter(\n        (img) => !taskUUIDs.includes(img.taskUUID)\n      );\n      return imagesWithSimilarTask;\n    } else {\n      throw error;\n    }\n  }\n\n  disconnect = async () => {\n    this._shouldReconnect = false;\n    this._ws?.terminate?.();\n    this._ws?.close?.();\n  };\n\n  private connected = () =>\n    this.isWebsocketReadyState() && !!this._connectionSessionUUID;\n  //end of data\n}\n","import { RunwareBase } from \"./Runware-base\";\nimport ReconnectingWebsocket from \"./reconnect\";\nimport { ReconnectingWebsocketProps, RunwareBaseType } from \"./types\";\n\nexport class RunwareClient extends RunwareBase {\n  constructor(props: RunwareBaseType) {\n    const { shouldReconnect, ...rest } = props;\n\n    super(rest);\n    this._ws = new (ReconnectingWebsocket as any)(\n      this._url\n    ) as ReconnectingWebsocketProps;\n    this.connect();\n  }\n}\n","// @ts-ignore\n// import ReconnectingWebsocket from \"./reconnect\";\nimport WebSocket from \"ws\";\n\nimport { RunwareBase } from \"./Runware-base\";\nimport { ETaskType, RunwareBaseType, SdkType } from \"./types\";\nimport { delay } from \"./utils\";\n\n// let allImages: IImage[] = [];\n\nexport class RunwareServer extends RunwareBase {\n  _instantiated: boolean = false;\n  _listeners: any[] = [];\n  _reconnectingIntervalId: null | any = null;\n  _pingTimeout: any;\n  _pongListener: any;\n\n  constructor(props: RunwareBaseType) {\n    super(props);\n\n    this._sdkType = SdkType.SERVER;\n    this.connect();\n  }\n\n  // protected addListener({\n  //   lis,\n  //   check,\n  //   groupKey,\n  // }: {\n  //   lis: (v: any) => any;\n  //   check: (v: any) => any;\n  //   groupKey?: string;\n  // }) {\n  //   const listener = (msg: any) => {\n  //     if (msg?.error) {\n  //       lis(msg);\n  //     } else if (check(msg)) {\n  //       lis(msg);\n  //     }\n  //   };\n  //   const groupListener = { key: getUUID(), listener, groupKey };\n  //   this._listeners.push(groupListener);\n  //   const destroy = () => {\n  //     this._listeners = removeListener(this._listeners, groupListener);\n  //   };\n\n  //   return {\n  //     destroy,\n  //   };\n  // }\n\n  protected async connect() {\n    if (!this._url) return;\n\n    this.resetConnection();\n\n    this._ws = new WebSocket(this._url, {\n      perMessageDeflate: false,\n    });\n\n    // delay(1);\n\n    this._ws.on(\"error\", () => {});\n    this._ws.on(\"close\", () => {\n      this.handleClose();\n    });\n\n    this._ws.on(\"open\", () => {\n      if (this._reconnectingIntervalId) {\n        clearInterval(this._reconnectingIntervalId);\n      }\n      if (this._connectionSessionUUID && this.isWebsocketReadyState()) {\n        this.send({\n          taskType: ETaskType.AUTHENTICATION,\n          apiKey: this._apiKey,\n          connectionSessionUUID: this._connectionSessionUUID,\n        });\n      } else {\n        if (this.isWebsocketReadyState()) {\n          this.send({\n            apiKey: this._apiKey,\n            taskType: ETaskType.AUTHENTICATION,\n          });\n        }\n      }\n\n      this.addListener({\n        taskUUID: ETaskType.AUTHENTICATION,\n        lis: (m) => {\n          if (m?.error) {\n            this._connectionError = m;\n            return;\n          }\n          this._connectionSessionUUID =\n            m?.[ETaskType.AUTHENTICATION]?.[0]?.connectionSessionUUID;\n          this._connectionError = undefined;\n        },\n      });\n    });\n\n    this._ws.on(\"message\", (e: any, isBinary: any) => {\n      const data = isBinary ? e : e?.toString();\n      if (!data) return;\n      const m = JSON.parse(data);\n\n      // console.log(\"response\", JSON.stringify(m, null, 4));\n\n      this._listeners.forEach((lis) => {\n        const result = lis.listener(m);\n        if (result) {\n          return;\n        }\n      });\n    });\n  }\n\n  protected send = (msg: Object) => {\n    this._ws.send(JSON.stringify([msg]));\n  };\n\n  protected handleClose() {\n    if (this.isInvalidAPIKey()) {\n      return;\n    }\n    if (this._reconnectingIntervalId) {\n      clearInterval(this._reconnectingIntervalId);\n    }\n\n    if (this._shouldReconnect) {\n      setTimeout(() => this.connect(), 1000);\n    }\n    // this._reconnectingIntervalId = setInterval(() => this.connect(), 1000);\n  }\n\n  protected resetConnection = () => {\n    if (this._ws) {\n      this._listeners.forEach((list) => {\n        list?.destroy?.();\n      });\n      this._ws.removeAllListeners(); // Remove all listeners\n      if (this._ws.readyState === 1) {\n        this._ws.terminate();\n        this._ws.close(); // Attempt to close gracefully\n      }\n\n      this._ws = null;\n      this._listeners = [];\n    }\n  };\n\n  protected heartBeat() {\n    clearTimeout(this._pingTimeout);\n\n    this._pingTimeout = setTimeout(() => {\n      if (this.isWebsocketReadyState()) {\n        this.send({ ping: true });\n      }\n    }, 5000);\n  }\n\n  //end of data\n}\n","// @ts-ignore\nimport { RunwareClient } from \"./Runware-client\";\nimport { RunwareServer } from \"./Runware-server\";\n\nlet Runware: typeof RunwareClient | typeof RunwareServer;\n\nif (typeof window === \"undefined\") {\n  Runware = RunwareServer;\n} else {\n  Runware = RunwareClient;\n}\n\nexport { Runware };\n"],"mappings":"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","names":["require_reconnect","__commonJSMin","exports","module","isWebSocket","constructor","isGlobalWebSocket","getDefaultOptions","bypassProperty","src","dst","name","value","initReconnectionDelay","config","updateReconnectionDelay","previousDelay","newDelay","LEVEL_0_EVENTS","reassignEventListeners","ws","oldWs","listeners","type","listener","options","ReconnectingWebsocket","url","protocols","connectingTimeout","reconnectDelay","retriesCount","shouldRetry","key","log","params","emitError","code","msg","err","fn","handleClose","connect","reason","keepClosed","fastClose","delay","fakeCloseEvent","data","l","Runware_exports","__export","EControlMode","EModelArchitecture","EModelConditioning","EModelFormat","EModelType","EOpenPosePreProcessor","EPhotoMakerEnum","EPreProcessor","EPreProcessorGroup","ETaskType","Environment","Runware","RunwareClient","RunwareServer","SdkType","__toCommonJS","Environment","SdkType","ETaskType","EControlMode","EPreProcessorGroup","EPreProcessor","EOpenPosePreProcessor","EModelFormat","EModelArchitecture","EModelType","EModelConditioning","EPhotoMakerEnum","import_uuid","TIMEOUT_DURATION","MINIMUM_TIMEOUT_DURATION","POLLING_INTERVAL","BASE_RUNWARE_URLS","removeFromAray","col","targetElem","i","getIntervalWithPromise","callback","debugKey","timeoutDuration","shouldThrowError","pollingInterval","resolve","reject","timeoutId","intervalId","fileToBase64","file","reader","getUUID","uuidv4","isValidUUID","uuid","validateUUID","accessDeepObject","key","data","useZero","shouldReturnString","acc","curr","returnZero","currentValue","index","delay","time","milliseconds","resolve","removeListener","listeners","listener","lis","evaluateNonTrue","key","value","getRandomNumber","min","max","getRandomSeed","getIntervalAsyncWithPromise","callback","debugKey","timeoutDuration","TIMEOUT_DURATION","shouldThrowError","pollingInterval","POLLING_INTERVAL","MINIMUM_TIMEOUT_DURATION","resolve","reject","timeoutId","intervalId","error","asyncRetry","apiCall","options","delayInSeconds","callback","maxRetries","error","delay","RunwareBase","apiKey","url","BASE_RUNWARE_URLS","shouldReconnect","globalMaxRetries","timeoutDuration","TIMEOUT_DURATION","msg","file","asyncRetry","taskUUID","getUUID","isValidUUID","imageBase64","fileToBase64","e","inputImage","preProcessorType","height","width","outputType","outputFormat","highThresholdCanny","lowThresholdCanny","includeHandsAndFaceOpenPose","includeCost","outputQuality","customTaskUUID","_taskUUID","retry","includeGenerationTime","includePayload","totalRetry","lis","startTime","image","payload","evaluateNonTrue","guideImage","getIntervalWithPromise","resolve","reject","uploadedImage","params","inputs","deliveryMethod","skipResponse","model","imageUploaded","request","rest","inputAudios","referenceVideos","upscaleFactor","prompt","promptMaxLength","promptVersions","response","reducedPrompt","onUploadStream","addModelPayload","result","errorResult","error","moreOptions","onPartialImages","numberResults","photoMakerPayload","taskUUIDs","retryCount","imagesWithSimilarTask","img","imageRemaining","getRandomSeed","promise","debugKey","isMultiple","restPayload","groupKey","onPartialResponse","taskWithSimilarTaskUUID","audio","taskRemaining","listener","value","errorValue","mainValue","res","item","allResults","getIntervalAsyncWithPromise","responseItem","uuid","err","props","instance","arrayMessage","arrayErrors","filteredMessage","v","groupListener","removeListener","m","data","removeFromAray","requestPayload","images","accessDeepObject","uploadEndpoint","checkNSFW","positivePrompt","negativePrompt","seedImage","maskImage","strength","steps","scheduler","seed","CFGScale","clipSkip","usePromptWeighting","promptWeighting","refiner","maskMargin","controlNet","lora","embeddings","ipAdapters","providerSettings","outpaint","acceleratorOptions","advancedFeatures","referenceImages","requestObject","seedImageUUID","maskImageUUID","controlNetData","uploadedMaskInitiator","i","controlData","endStep","startStep","weight","controlMode","startStepPercentage","endStepPercentage","controlNetModel","newRequestObject","retryInterval","pollingInterval","MAX_RETRY","localConnectionUUID","retryIntervalId","pollingIntervalId","clearAllIntervals","hasConnected","shouldCallServer","SHOULD_RETRY","shouldThrowError","intervalId","isAsyncResponse","newData","import_reconnect","RunwareClient","RunwareBase","props","shouldReconnect","rest","ReconnectingWebsocket","import_ws","RunwareServer","RunwareBase","props","msg","list","WebSocket","m","e","isBinary","data","lis","Runware","RunwareServer","RunwareClient"]}